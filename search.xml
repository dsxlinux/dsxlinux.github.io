<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python标准库02]]></title>
    <url>%2F2018%2F06%2F22%2Fpython-stdmod02%2F</url>
    <content type="text"><![CDATA[本文主要介绍Python标准库。 1.re模块re模块中常用功能函数①compile()编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。）格式：re.compile(pattern,flags=0)pattern: 编译时用的表达式字符串。flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等。常用的flags有：|标志|含义||:-|:-||re.S(DOTALL)|使.匹配包括换行在内的所有字符|re.I(IGNORECASE)|使匹配对大小写不敏感|re.L(LOCALE)|做本地化识别（locale-aware)匹配，法语等|re.M(MULTILINE)|多行匹配，影响^和$|re.X(VERBOSE)|该标志通过给予更灵活的格式以便将正则表达式写得更易于理解|re.U|根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B 123456import rett = "Tina is a good girl, she is cool, clever, and so on..."rr = re.compile(r'\w*oo\w*')print(rr.findall(tt)) #查找所有包含'oo'的单词执行结果如下：['good', 'cool'] ② match()决定RE是否在字符串刚开始的位置匹配。//注：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’格式：re.match(pattern, string, flags=0)print(re.match(‘com’,’comwww.runcomoob&#39;).group())print(re.match(‘com’,’Comwww.runcomoob&#39;,re.I).group())执行结果如下：comcom ③ search()格式：re.search(pattern, string, flags=0)re.search函数会在字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。 print(re.search(‘\dcom’,’www.4comrunoob.5com&#39;).group()) 执行结果如下： 4com注：match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法：group() 返回被 RE 匹配的字符串start() 返回匹配开始的位置end() 返回匹配结束的位置span() 返回一个元组包含匹配 (开始,结束) 的位置group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串。group()返回re整体匹配的字符串， b. group (n,m) 返回组号为n，m所匹配的字符串，如果组号不存在，则返回indexError异常 c.groups() groups()方法返回一个包含正则表达式中所有小组字符串的元组，从 1 到所含的小组号，通常groups()不需要参数，返回一个元组，元组中的元就是正则表达式中定义的组。import rea = “123abc456” print(re.search(“([0-9])([a-z])([0-9])”,a).group(0)) #123abc456,返回整体 print(re.search(“([0-9])([a-z])([0-9])”,a).group(1)) #123 print(re.search(“([0-9])([a-z])([0-9])”,a).group(2)) #abc print(re.search(“([0-9])([a-z])([0-9]*)”,a).group(3)) #456 ###group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。###④ findall()re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。格式：re.findall(pattern, string, flags=0)p = re.compile(r’\d+’)print(p.findall(‘o1n2m3k4’))执行结果如下：[‘1’, ‘2’, ‘3’, ‘4’]import rett = “Tina is a good girl, she is cool, clever, and so on…”rr = re.compile(r’\woo\w‘)print(rr.findall(tt))print(re.findall(r’(\w)*oo(\w)’,tt))#()表示子表达式执行结果如下：[‘good’, ‘cool’][(‘g’, ‘d’), (‘c’, ‘l’)]⑤ finditer()搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。格式：re.finditer(pattern, string, flags=0)iter = re.finditer(r’\d+’,’12 drumm44ers drumming, 11 … 10 …’)for i in iter: print(i) print(i.group()) print(i.span())执行结果如下： &lt;_sre.SRE_Match object; span=(0, 2), match=’12’&gt;(0, 2) &lt;_sre.SRE_Match object; span=(8, 10), match=’44’&gt;(8, 10) &lt;_sre.SRE_Match object; span=(24, 26), match=’11’&gt;(24, 26) &lt;_sre.SRE_Match object; span=(31, 33), match=’10’&gt;(31, 33)⑥ split()按照能够匹配的子串将string分割后返回列表。可以使用re.split来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。格式：re.split(pattern, string[, maxsplit])maxsplit用于指定最大分割次数，不指定将全部分割。 print(re.split(‘\d+’,’one1two2three3four4five5’))执行结果如下：[‘one’, ‘two’, ‘three’, ‘four’, ‘five’, ‘’]⑦ sub()使用re替换string中每一个匹配的子串后返回替换后的字符串。格式：re.sub(pattern, repl, string, count)import retext = “JGood is a handsome boy, he is cool, clever, and so on…”print(re.sub(r’\s+’, ‘-‘, text))执行结果如下：JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on…其中第二个函数是替换后的字符串；本例中为’-‘第四个参数指替换个数。默认为0，表示每个匹配项都替换。re.sub还允许使用函数对匹配项的替换进行复杂的处理。如：re.sub(r’\s’, lambda m: ‘[‘ + m.group(0) + ‘]’, text, 0)；将字符串中的空格’ ‘替换为’[ ]’。import retext = “JGood is a handsome boy, he is cool, clever, and so on…”print(re.sub(r’\s+’, lambda m:’[‘+m.group(0)+’]’, text,0))执行结果如下：JGood[ ]is[ ]a[ ]handsome[ ]boy,[ ]he[ ]is[ ]cool,[ ]clever,[ ]and[ ]so[ ]on…⑧ subn()返回替换次数格式：subn(pattern, repl, string, count=0, flags=0)print(re.subn(‘[1-2]’,’A’,’123456abcdef’))print(re.sub(“g.t”,”have”,’I get A, I got B ,I gut C’))print(re.subn(“g.t”,”have”,’I get A, I got B ,I gut C’))执行结果如下：(‘AA3456abcdef’, 2)I have A, I have B ,I have C(‘I have A, I have B ,I have C’, 3) 2.time模块在Python中，通常有这几种方式来表示时间：1）时间戳 2）格式化的时间字符串 3）元组（struct_time）共九个元素。12345&gt;&gt;&gt; time.time() //返回unix时间戳&gt;&gt;&gt; time.localtime() //用一个元组装起来的9组数字处理时间&gt;&gt;&gt; time.sleep(5) //延时函数&gt;&gt;&gt; time.asctime( time.localtime() ) //获取可读的时间模式&gt;&gt;&gt; print time.strftime("%Y-%m-%d %H:%M:%S",time.localtime()) 3.random模块1234567891011121314151617&gt;&gt;&gt; import random //生成一个0到1的随机符点数: 0 &lt;= n &lt; 1.0&gt;&gt;&gt; random.random()&gt;&gt;&gt; random.uniform(10,20) //生成的随机数n: a &lt;= n &lt;= b&gt;&gt;&gt; random.randint(1,20) //生成的随机数n: a &lt;= n &lt;= b&gt;&gt;&gt; random.randrange(1,10,2)&gt;&gt;&gt; random.choice(["JGood","is", "a","handsome", "boy"])&gt;&gt;&gt; p = ["Python","is", "powerful","simple", "and so on..."]&gt;&gt;&gt; random.shuffle(p) //打乱&gt;&gt;&gt; print p['simple', 'and so on...', 'is', 'powerful', 'Python']&gt;&gt;&gt; list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; slice = random.sample(list, 5) &gt;&gt;&gt; print slice[1, 6, 7, 4, 3]&gt;&gt;&gt; print list[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 4.csv模块读csv文件：语法：reader(csvfile, dialect=’excel’, **fmtparams) import csvreader=csv.reader(open(‘foo.csv’,’rb’))for item in reader:… print item写csv文件：import csvwriter=csv.writer(open(‘foo.csv’,’wb+’))writer.writerow([‘tianqi’,’26’,’79’])字典方式读写： 读 import csvwith open(‘names.csv’) as csvfile:… reader = csv.DictReader(csvfile)… for row in reader:… print(row[‘first_name’], row[‘last_name’])…Baked BeansLovely SpamWonderful Spam 写import csvwith open(‘names.csv’, ‘w’) as csvfile: fieldnames = [‘first_name’, ‘last_name’] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() writer.writerow({&apos;first_name&apos;: &apos;Baked&apos;, &apos;last_name&apos;: &apos;Beans&apos;}) writer.writerow({&apos;first_name&apos;: &apos;Lovely&apos;, &apos;last_name&apos;: &apos;Spam&apos;}) writer.writerow({&apos;first_name&apos;: &apos;Wonderful&apos;, &apos;last_name&apos;: &apos;Spam&apos;})]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python标准库01]]></title>
    <url>%2F2018%2F06%2F22%2Fpython-stdmod01%2F</url>
    <content type="text"><![CDATA[本文主要介绍Python标准库。 1.os模块 操作文件以下内容在shell终端操作123456# touch 1.txt //创建文件# ls1.txt# echo "os module" &gt; 1.txt //写入内容# cat 1.txt os module 以下是python终端中操作12345678# python //进入python命令行&gt;&gt;&gt; import os //导入os模块&gt;&gt;&gt; dir(os) //获得os模块的帮助&gt;&gt;&gt; os.rename('1.txt','2.txt') //将1.txt重命名为2.txt&gt;&gt;&gt; os.remove('2.txt') //删除2.txt文件&gt;&gt;&gt; os.mknod('test.txt') //创建一个空文件&gt;&gt;&gt; os.stat('test.txt') //获取文件属性&gt;&gt;&gt; os.chmod('test.txt',0666) //修改文件权限 操作目录 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; os.getcwd() //获取当前目录'/python'&gt;&gt;&gt; os.listdir('/python') //列出文件和目录['test.txt']&gt;&gt;&gt; os.mkdir('foo') //创建目录&gt;&gt;&gt; os.listdir('.')['test.txt', 'foo']&gt;&gt;&gt; os.rmdir('foo') //删除目录&gt;&gt;&gt; os.mkdir('foo') //重新创建目录&gt;&gt;&gt; os.chdir('foo') //进入foo目录&gt;&gt;&gt; os.getcwd() //获取当前目录'/python/foo'&gt;&gt;&gt; os.makedirs('a/b/c') //创建多级目录&gt;&gt;&gt; os.removedirs('a/b/c') //删除多级目录&gt;&gt;&gt; os.getcwd() //当前目录'/python'&gt;&gt;&gt; os.listdir('.') //当前目录文件列表['test.txt', 'foo']&gt;&gt;&gt; os.chdir('foo') //进入foo目录&gt;&gt;&gt; os.mknod('1.txt') //创建文件，此时foo目录不为空&gt;&gt;&gt; os.chdir('..') //返回上一级目录&gt;&gt;&gt; os.getcwd()'/python'&gt;&gt;&gt; os.rmdir('foo') //使用rmdir删除会报错，怎么删除？&gt;&gt;&gt; import shutil&gt;&gt;&gt; shutil.rmtree('foo') //删除非空目录 系统相关 12345678910111213&gt;&gt;&gt; os.sep //操作系统特定的路径分隔符'/'&gt;&gt;&gt; os.name //正在使用的工作平台，Windows是'nt'，Linux/Unix是'posix'。'posix'&gt;&gt;&gt; os.getenv('PATH') //读取和设置环境变量:os.getenv() 与os.putenv()'/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin'&gt;&gt;&gt; os.linesep //当前平台使用的行终止符'\n'&gt;&gt;&gt; os.system('ls -l') //调用系统命令&gt;&gt;&gt; os.pathsep':'&gt;&gt;&gt; os.extsep'.' os.path模块 12345678910111213141516171819202122232425262728# ls -ldrwxr-xr-x 2 root root 4096 Oct 23 16:30 foo-rw-rw-rw- 1 root root 0 Oct 23 13:15 test.txt//当前目录下一个目录和一个文件# python //进入python终端&gt;&gt;&gt; import os&gt;&gt;&gt; os.path.isfile('test.txt') //判断是不是文件True&gt;&gt;&gt; os.path.isdir('foo') //判断是不是目录True&gt;&gt;&gt; os.path.isdir('test.txt')False&gt;&gt;&gt; os.path.split('/python/foo') //返回路径的目录和文件名('/python', 'foo')&gt;&gt;&gt; os.path.split('/python/foo/')('/python/foo', '')&gt;&gt;&gt; os.path.getsize('test.txt') //返回文件大小，如果为目录，返回01551&gt;&gt;&gt; os.path.abspath('.') //获得绝对路径'/python'&gt;&gt;&gt; os.path.join('/python','test.txt') //连接目录和文件名'/python/test.txt'&gt;&gt;&gt; os.path.basename('/usr/bin/env') //返回文件名'env'&gt;&gt;&gt; os.path.dirname('/usr/bin/env') //返回文件路径'/usr/bin'&gt;&gt;&gt; os.path.splitext('test.txt') //分离文件名和扩展名('test', '.txt') 2.shutil模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&gt;&gt;&gt; shutil.copyfile('/root/nginx.conf','./nginx.conf') //复制文件&gt;&gt;&gt; shutil.copy('/root/nginx.conf','./test.txt') //复制数据&gt;&gt;&gt; shutil.copytree('/opt/bar','/python/bar') //递归复制文件夹&gt;&gt;&gt; shutil.move('/python/bar','/root/') //移动目录&gt;&gt;&gt; shutil.rmtree('/root/bar') //删除目录# ls -ldrwxr-xr-x 2 root root 4096 Oct 23 16:30 foo-rw-rw-rw- 1 root root 1258 Oct 23 16:51 nginx.conf-rw-r--r-- 1 root root 1258 Oct 23 16:52 test.txt&gt;&gt;&gt; import shutil&gt;&gt;&gt; shutil.copymode('nginx.conf','test.txt') //复制权限# ls -ldrwxr-xr-x 2 root root 4096 Oct 23 16:30 foo-rw-rw-rw- 1 root root 1258 Oct 23 16:51 nginx.conf-rw-rw-rw- 1 root root 1258 Oct 23 16:52 test.txt&gt;&gt;&gt; shutil.copystat('nginx.conf','test.txt') //复制属性&gt;&gt;&gt; shutil.copy2('nginx.conf','test.txt') //先copyfile后copystatmake_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,dry_run=0, owner=None, group=None, logger=None) #压缩打包base_name： 压缩打包后的文件名或者路径名format： 压缩或者打包格式 "zip", "tar", "bztar"or "gztar"root_dir : 将哪个目录或者文件打包（也就是源文件）&gt;&gt;&gt; shutil.make_archive('python','gztar',root_dir='/python/') '/python/python.tar.gz'shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细：import zipfile# 压缩z = zipfile.ZipFile('laxi.zip', 'w')z.write('a.log')z.write('data.data')z.close()# 解压z = zipfile.ZipFile('laxi.zip', 'r')z.extractall()z.close()import tarfile# 压缩tar = tarfile.open('your.tar','w')tar.add('/Users/wupeiqi/PycharmProjects/bbs2.log', arcname='bbs2.log')tar.add('/Users/wupeiqi/PycharmProjects/cmdb.log', arcname='cmdb.log')tar.close()# 解压tar = tarfile.open('your.tar','r')tar.extractall() # 可设置解压地址tar.close() 3.sys模块sys.argv功能：在外部向程序内部传递参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# cat argv.py #!/usr/bin/env pythonimport sysprint sys.argv[0]print sys.argv[1]# python argv.py aa argv.pyaa# cat argv.py#!/usr/bin/env python#coding:utf-8import sysif len(sys.argv)&gt;1: print "传递了",len(sys.argv)-1,"个参数"for arg in sys.argv[1:]: print argelse: print "没有传参"# python argv.py 没有传参# python argv.py 11 22 33 aa bb cc传递了 6 个参数112233aabbccsys.exit(n)功能：解释器自动退出&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.exit(0)&gt;&gt;&gt; sys.getdefaultencoding() //获取系统当前编码'ascii'&gt;&gt;&gt; sys.getfilesystemencoding() //获取文件系统使用编码方式'UTF-8'&gt;&gt;&gt; sys.path //获取指定模块搜索路径的集合&gt;&gt;&gt; sys.platform //获取当前系统平台'linux2'sys.stdin,sys.stdout,sys.stderr //标准I/O 4.platform模块12345678&gt;&gt;&gt; import platform&gt;&gt;&gt; platform.platform() //获取操作系统名称及版本号&gt;&gt;&gt; platform.version() //获取操作系统版本号&gt;&gt;&gt; platform.architecture() //获取操作系统的位数&gt;&gt;&gt; platform.machine() //计算机类型&gt;&gt;&gt; platform.node() //计算机的网络名称&gt;&gt;&gt; platform.processor() //计算机处理器信息&gt;&gt;&gt; platform.uname() //包含上面所有的信息汇总]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python自动化运维03]]></title>
    <url>%2F2018%2F06%2F22%2Fpython-devops03%2F</url>
    <content type="text"><![CDATA[本文主要介绍Python自动化运维的常用模块，比如：paramiko、Fabric等。 1. paramiko模块 基于用户名和密码的 sshclient 方式登录 123456789101112131415161718#!/usr/bin/env python# coding:utf-8import paramikohost='123.20.62.15'port=22username='root'password='your pass'if __name__ == '__main__': paramiko.util.log_to_file('paramiko.log') ssh=paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(host,port,username,password) stdin,stdout,stderr=ssh.exec_command('ifconfig') print stdout.read() ssh.close() 基于用户名和密码的 transport 方式登录示例1： 12345678910111213141516171819#!/usr/bin/env python# coding:utf-8import paramikohost='123.20.62.15'port=22username='root'password='your pass'if __name__ == '__main__': trans=paramiko.Transport(host,port) trans.connect(username=username,password=password) ssh=paramiko.SSHClient() ssh._transport=trans stdin, stdout, stderr = ssh.exec_command('df -hl') print(stdout.read().decode()) trans.close() 示例2：123456789101112131415161718192021222324#!/usr/bin/env python# coding:utf-8import paramikoimport oshost='123.20.62.15'port=22username='root'password='your pass'dir_path='/root/'if __name__ == '__main__': trans=paramiko.Transport(host,port) trans.connect(username=username,password=password) sftp=paramiko.SFTPClient.from_transport(trans) files=sftp.listdir(dir_path) for f in files: print f sftp.get(os.path.join(dir_path,f),f) trans.close() 基于公钥密钥的 SSHClient 方式登录 1234567891011121314151617181920#!/usr/bin/env python# coding:utf-8import paramiko# 指定本地的RSA私钥文件,如果建立密钥对时设置的有密码，password为设定的密码，如无不用指定password参数pkey = paramiko.RSAKey.from_private_key_file('/home/super/.ssh/id_rsa', password='12345')# 建立连接ssh = paramiko.SSHClient()ssh.connect(hostname='192.168.2.129', port=22, username='super', pkey=pkey)# 执行命令stdin, stdout, stderr = ssh.exec_command('df -hl')# 结果放到stdout中，如果有错误将放到stderr中print(stdout.read().decode())# 关闭连接ssh.close() 基于密钥的 Transport 方式登录 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python# coding:utf-8import paramiko# 指定本地的RSA私钥文件,如果建立密钥对时设置的有密码，password为设定的密码，如无不用指定password参数pkey = paramiko.RSAKey.from_private_key_file('/home/super/.ssh/id_rsa', password='12345')# 建立连接trans = paramiko.Transport(('192.168.2.129', 22))trans.connect(username='super', pkey=pkey)# 将sshclient的对象的transport指定为以上的transssh = paramiko.SSHClient()ssh._transport = trans# 执行命令，和传统方法一样stdin, stdout, stderr = ssh.exec_command('df -hl')print(stdout.read().decode())# 关闭连接trans.close()#################### 传文件 SFTP ###################!/usr/bin/env python# coding:utf-8import paramiko# 实例化一个trans对象# 实例化一个transport对象trans = paramiko.Transport(('192.168.2.129', 22))# 建立连接trans.connect(username='super', password='super')# 实例化一个 sftp对象,指定连接的通道sftp = paramiko.SFTPClient.from_transport(trans)# 发送文件sftp.put(localpath='/tmp/11.txt', remotepath='/tmp/22.txt')# 下载文件# sftp.get(remotepath, localpath)trans.close() 实现输入命令立马返回结果的功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python# coding:utf-8import paramikoimport osimport selectimport sys# 建立一个sockettrans = paramiko.Transport(('192.168.2.129', 22))# 启动一个客户端trans.start_client()# 如果使用rsa密钥登录的话'''default_key_file = os.path.join(os.environ['HOME'], '.ssh', 'id_rsa')prikey = paramiko.RSAKey.from_private_key_file(default_key_file)trans.auth_publickey(username='super', key=prikey)'''# 如果使用用户名和密码登录trans.auth_password(username='super', password='super')# 打开一个通道channel = trans.open_session()# 获取终端channel.get_pty()# 激活终端，这样就可以登录到终端了，就和我们用类似于xshell登录系统一样channel.invoke_shell()# 下面就可以执行你所有的操作，用select实现# 对输入终端sys.stdin和 通道进行监控,# 当用户在终端输入命令后，将命令交给channel通道，这个时候sys.stdin就发生变化，select就可以感知# channel的发送命令、获取结果过程其实就是一个socket的发送和接受信息的过程while True: readlist, writelist, errlist = select.select([channel, sys.stdin,], [], []) # 如果是用户输入命令了,sys.stdin发生变化 if sys.stdin in readlist: # 获取输入的内容 input_cmd = sys.stdin.read(1) # 将命令发送给服务器 channel.sendall(input_cmd) # 服务器返回了结果,channel通道接受到结果,发生变化 select感知到 if channel in readlist: # 获取结果 result = channel.recv(1024) # 断开连接后退出 if len(result) == 0: print("\r\n**** EOF **** \r\n") break # 输出到屏幕 sys.stdout.write(result.decode()) sys.stdout.flush()# 关闭通道channel.close()# 关闭链接trans.close() 2. Python运维管理组件Fabric123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python# -*- coding: utf-8 -*-from datetime import datetimefrom fabric.api import *# 登录用户和主机名：env.user = 'root'env.password='xxxxx'env.hosts = ['192.168.0.1','192.168.0.2'] # 如果有多个主机，fabric会自动依次部署def pack(): ' 定义一个pack任务 ' # 打一个tar包： tar_files = ['*.py', 'static/*', 'templates/*', 'favicon.ico'] local('rm -f example.tar.gz') local('tar -czvf example.tar.gz --exclude=\'*.tar.gz\' --exclude=\'fabfile.py\' %s' % ' '.join(tar_files))def deploy(): ' 定义一个部署任务 ' # 远程服务器的临时文件： remote_tmp_tar = '/tmp/example.tar.gz' tag = datetime.now().strftime('%y.%m.%d_%H.%M.%S') run('rm -f %s' % remote_tmp_tar) # 上传tar文件至远程服务器： put('shici.tar.gz', remote_tmp_tar) # 解压： remote_dist_dir = '/srv/www.example.com@%s' % tag remote_dist_link = '/srv/www.example.com' run('mkdir %s' % remote_dist_dir) with cd(remote_dist_dir): run('tar -xzvf %s' % remote_tmp_tar) # 设定新目录的www-data权限: run('chown -R www-data:www-data %s' % remote_dist_dir) # 删除旧的软链接： run('rm -f %s' % remote_dist_link) # 创建新的软链接指向新部署的目录： run('ln -s %s %s' % (remote_dist_dir, remote_dist_link)) run('chown -R www-data:www-data %s' % remote_dist_link) # 重启服务： fcgi = '/etc/init.d/py-fastcgi' with settings(warn_only=True): run('%s stop' % fcgi) run('%s start' % fcgi)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python自动化运维02]]></title>
    <url>%2F2018%2F06%2F22%2Fpython-devops02%2F</url>
    <content type="text"><![CDATA[本文主要介绍Python自动化运维的常用模块，比如：XlsxWriter、rrdtool等。 1. 用XlsxWriter模块创建报表 安装xlsxwriter模块 1# pip install xlsxwriter 推荐使用pip安装 xlsxwriter模块使用 1234567891011#!/usr/bin/env python# -*- coding:utf-8 -*-import xlsxwriterworkbook = xlsxwriter.Workbook('hello.xlsx')worksheet = workbook.add_worksheet()worksheet.write('A1', 'Hello world')worksheet.write('A2', 'Hello world')worksheet.write('B1', 'Hello world')worksheet.write('B2', 'Hello world')workbook.close() 2. 绘图大师rrdtool rrdtool绘图 创建rrd123456789101112#!/usr/bin/pythonimport rrdtool rrdb=rrdtool.create('rest.rrd','--step','60','--start','1369982786', 'DS:input:GAUGE:120:U:U', 'DS:output:GAUGE:120:U:U', 'RRA:LAST:0.5:1:600', 'RRA:AVERAGE:0.5:5:600', 'RRA:MAX:0.5:5:600', 'RRA:MIN:0.5:5:600')if rrdb: print rrdtool.error() rrd插入数据1234567891011#!/usr/bin/pythonimport timeimport psutilimport rrdtool for keys in psutil.network_io_counters(pernic=True): if keys == 'em1': sent=psutil.network_io_counters(pernic=True)[keys][0] recv=psutil.network_io_counters(pernic=True)[keys][1] up=rrdtool.updatev('rest.rrd','N:%d:%d' % (sent,recv)) print up 根据rrd绘图12345678910111213141516#!/usr/bin/pythonimport rrdtool rrdtool.graph('rest.png','--start','1369983960', '--title','my rrd graph test', '--vertical-label','bits', 'DEF:input=rest.rrd:input:LAST', 'DEF:output=rest.rrd:output:LAST', 'LINE1:input#0000FF:In traffic', 'LINE1:output#00FF00:Out traffic\\r', 'CDEF:bytes_in=input,8,*', 'CDEF:bytes_out=output,8,*', 'COMMENT:\\n', 'GPRINT:bytes_in:LAST:LAST in traffic\: %6.2lf %Sbps', 'COMMENT: ', 'GPRINT:bytes_out:LAST:LAST out traffic\: %6.2lf %Sbps') 3. 利用Python-nmap实现高效端口扫描12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/env python# -*- coding: utf-8 -*-import sysimport nmapscan_row=[]input_data = raw_input('Please input host and port:')scan_row = input_data.split(" ")if len(scan_row) != 2: print "Input error!" sys.exit(1)hosts = scan_row[0]port = scan_row[1]try: nm = nmap.PortScanner()except namp.PortScannerError: print "Namp not found",sys.exc_info()[0] sys.exit[2]except: print "Unexpected error:",sys.exc_info()[0] sys.exit[3]try: nm.scan(hosts=hosts,arguments=' -v -sS -p'+port)except Exception as e: print "Scan error:"+str(e)for host in nm.all_hosts(): print '------------------------------------------------' print 'Host: %s (%s)' % host,nm[host].hostname() print 'State: %s' % nm[host].state() for proto in nm[host].all_protocols(): print '--------------' print 'protocol: %s' % proto lport = nm[host][proto].keys() lport.sort() for port in lport: print 'port: %s\tstate: %s' % port,nm[host][proto][port]['state']]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python自动化运维01]]></title>
    <url>%2F2018%2F06%2F22%2Fpython-devops01%2F</url>
    <content type="text"><![CDATA[本文主要介绍Python自动化运维的常用模块，比如：psutil、Dnspython、smtplib等。 1. psutil模块 安装psutil模块 1# pip install psutil 推荐使用pip安装 获取系统信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python# -*- coding:utf-8 -*-import psutil# cpu信息print("CPU逻辑数量: %s" % psutil.cpu_count())print ("CPU物理核心: %s" % psutil.cpu_count(logical=False))# 内存信息mem = psutil.virtual_memory()print("系统总内存: %s" % mem.total)print("已用内存: %s" % mem.used)print("空闲内存: %s" % mem.free)# 磁盘信息disk_part = psutil.disk_partitions()for item in disk_part: print item.devicefor item in disk_part: print item.mountpoint print psutil.disk_usage(item.mountpoint)#print psutil.disk_io_counters() # 网络信息#print psutil.net_io_counters()net_ifaddrs = psutil.net_if_addrs()print net_ifaddrs["lo"][0].addressprint net_ifaddrs["eth0"][0].addressfor item in psutil.net_connections(): print item# 进程信息for item in psutil.pids(): print psutil.Process(item).name() # 进程名称 print psutil.Process(item).exe() # 进程exe路径 print psutil.Process(item).cwd() # 进程工作目录 print psutil.Process(item).cmdline() # 进程启动的命令行 print psutil.Process(item).ppid() # 父进程ID print psutil.Process(item).parent() # 父进程 print psutil.Process(item).children() # 子进程列表 print psutil.Process(item).status() # 进程状态 print psutil.Process(item).username() # 进程用户名 print psutil.Process(item).create_time() # 进程创建时间 print psutil.Process(item).terminal() # 进程终端 print psutil.Process(item).cpu_times() # 进程使用的CPU时间 print psutil.Process(item).memory_info() # 进程使用的内存 print psutil.Process(item).open_files() # 进程打开的文件 print psutil.Process(item).connections() # 进程相关网络连接 print psutil.Process(item).num_threads() # 进程的线程数量 print psutil.Process(item).threads() # 所有线程信息 print psutil.Process(item).environ() # 进程环境变量 print "======================================================" 2. dnspython模块 安装IPy模块 1# pip install dnspython 使用dnspython模块 12345678910111213#!/usr/bin/env python#-*-coding:utf8-*-import dns.resolverdomain = raw_input('请输入一个域名：')ans = dns.resolver.query(domain, "A")# ans = dns.resolver.query(domain, "CNAME")# ans = dns.resolver.query(domain, "NS")for i in ans.response.answer: print i.to_text() 3. smtplib模块smtplib模块发送邮件 123456789101112131415161718#!/usr/bin/env python#-*-coding:utf8-*-import smtplibimport stringHOST="smtp.126.com" # smtp主机SUBJECT="Test email from Python"TO="1730004882@qq.com" # 接收邮件的邮箱地址FROM="xxx@126.com" # 发送邮件的邮箱地址text="python rules them all!" # 邮件内容BODY=string.join(("From: %s" % FROM,"To: %s" % TO,"Subject: %s" % SUBJECT,"",text),"\r\n")server=smtplib.SMTP()server.connect(HOST,"25")server.starttls()server.login("xxx@126.com","password") # 发送邮件的邮箱地址和密码server.sendmail(FROM,[TO],BODY)server.quit() 4. difflib模块文件内容差异比对方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#### 比较2个字符串#!/usr/bin/env python#-*- coding:utf8 -*-import difflibtext1 = """This module provides classesand funcitions for comparing sequences 1"""text1_lines = text1.splitlines()text2 = """This module provides classesand funcitions for comparing sequences 2"""text2_lines = text2.splitlines()#d = difflib.Differ()#diff = d.compare(text1,text2)#print '\n'.join(list(diff))d = difflib.HtmlDiff()print d.make_file(text1_lines,text2_lines)### 对比配置文件差异#!/usr/bin/env pythonimport difflibimport systry: textfile1 = sys.argv[1] textfile2 = sys.argv[2]except Exception,e: print "Error:"+str(e) print "Usage: diffile.py filename1 filename2" sys.exit()def readfile(filename): try: fileHandle = open(filename,'rb') text = fileHandle.read().splitlines() fileHandle.close() return text except IOError as error: print('Read file Error:'+str(error)) sys.exit()if textfile1 == "" or textfile2 == "": print "Usage: diffile.py filename1 filename2" sys.exit()text1_lines = readfile(textfile1)text2_lines = readfile(textfile2)d = difflib.HtmlDiff()print d.make_file(text1_lines,text2_lines) 单个文件比较： 语法：filecmp.cmp(f1.f2[,shallow]) 比较f1和f2，相同返回true，不同返回false，shallow默认为true，会根据os.stat()比较，不会比较文件内容；反之则会比较内容。 12345&gt;&gt;&gt; import filecmp&gt;&gt;&gt; filecmp.cmp("/etc/passwd","/etc/passwd")True&gt;&gt;&gt; filecmp.cmp("/etc/passwd","/etc/shadow")False 5. pycurl模块pycurl模块是一个用C语言编写的libcurl P python实现，功能非常强大，支持的协议有FTP、HTTP、HTTPS、TELNET等，可以理解成linux下curl命令功能的python封装。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env python# -*- coding:utf8 -*-import os,sysimport timeimport sysimport pycurlURL="http://www.baidu.com"c = pycurl.Curl()c.setopt(pycurl.URL,URL)c.setopt(pycurl.CONNECTTIMEOUT,5)c.setopt(pycurl.TIMEOUT,5)c.setopt(pycurl.NOPROGRESS,1)c.setopt(pycurl.FORBID_REUSE,1)c.setopt(pycurl.MAXREDIRS,1)c.setopt(pycurl.DNS_CACHE_TIMEOUT,30)indexfile = open(os.path.dirname(os.path.realpath(__file__))+"/content.html","wb")c.setopt(pycurl.WRITEHEADER,indexfile)c.setopt(pycurl.WRITEDATA,indexfile)try: c.perform()except Exception,e: print "connection error:"+str(e) indexfile.close() c.close() sys.exit()NAMELOOKUP_TIME = c.getinfo(c.NAMELOOKUP_TIME)CONNECT_TIME = c.getinfo(c.CONNECT_TIME)PRETRANSFER_TIME = c.getinfo(c.PRETRANSFER_TIME)STARTTRANSFER_TIME = c.getinfo(c.STARTTRANSFER_TIME)TOTAL_TIME = c.getinfo(c.TOTAL_TIME)HTTP_CODE = c.getinfo(c.HTTP_CODE)SIZE_DOWNLOAD = c.getinfo(c.SIZE_DOWNLOAD)HEADER_SIZE = c.getinfo(c.HEADER_SIZE)SPEED_DOWNLOAD = c.getinfo(c.SPEED_DOWNLOAD)print "HTTP状态码：%s" %(HTTP_CODE)print "DNS解析时间：%.2f ms" %(NAMELOOKUP_TIME*1000)print "建立连接时间：%.2f ms" %(CONNECT_TIME*1000)print "准备传输时间：%.2f ms" %(PRETRANSFER_TIME*1000)print "传输开始时间：%.2f ms" %(STARTTRANSFER_TIME*1000)print "传输结束总时间：%.2f ms" %(TOTAL_TIME*1000)print "下载数据包大小：%d bytes/s" %(SIZE_DOWNLOAD)print "HTTP头部大小：%d byte" %(HEADER_SIZE)print "平均下载速度：%d bytes/s" %(SPEED_DOWNLOAD)indexfile.close()c.close()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F06%2F21%2Flinux-live%2F</url>
    <content type="text"><![CDATA[直播 这里是直播的观看地址，可以直接观看，不需要其他播放器的支持。请允许您的浏览器支持flash插件。原来使用播放器播放的方式也是可以的。 (function () { var player = new qcVideo.Player("id_video_container", { "live_url" : "http://2117.liveplay.myqcloud.com/live/2117_1e683aaee1.flv", "live_url2" : "http://2117.liveplay.myqcloud.com/live/2117_1e683aaee1.m3u8", "width" : 480, "height" : 320 }); })()]]></content>
  </entry>
  <entry>
    <title><![CDATA[CentOS6.x机器安装Python2.7]]></title>
    <url>%2F2018%2F06%2F21%2Fpython-update%2F</url>
    <content type="text"><![CDATA[本文主要介绍Centos6.x系统安装Python2.7。CentOS6.x默认的python版本为2.6.6，有些软件需要python2.7的环境。安装Python2.7有两种方式：源码安装或者YUM安装。 1.源码方式安装123456# wget https://www.python.org/ftp/python/2.7.12/Python-2.7.12.tgz# tar xf Python-2.7.12.tgz# cd Python-2.7.12# ./configure --prefix=/usr/local/python27# make# make install 2.YUM方式安装1234567891011121314# yum install centos-release-SCL 添加新的yum源# yum install scl-utils-build# yum --disablerepo="*" --enablerepo="centos-sclo-rh" list# yum install python27 -y# find / -name libpython2.7.so.1.0/opt/rh/python27/root/usr/lib64/libpython2.7.so.1.0# echo '/opt/rh/python27/root/usr/lib64/' &gt; /etc/ld.so.conf.d/python27.conf# /sbin/ldconfig# /sbin/ldconfig –v# mv /usr/bin/python /usr/bin/python.bak# ln -s /opt/rh/python27/root/usr/bin/python2.7 /usr/bin/python# python -V# vim /usr/bin/yum将第一行的内容改成：#!/usr/bin/python2.6]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL--避开登录时的[Warning]]]></title>
    <url>%2F2018%2F06%2F20%2Fmysql-warning%2F</url>
    <content type="text"><![CDATA[本文主要介绍如何避开MySQL数据库登录时，在终端中输入密码提示的warning。 在MySQL中, 如果显示的输入密码去登录的话, 就会有一个Warning显示出来, 提醒这种使用方式会不安全。在写脚本时，通过mysql命令行去执行SQL语句，获取执行的结果，这个提示会带来灾难。 1mysql: [Warning] Using a password on the command line interface can be insecure. 解决办法如下： 修改数据库配置文件 在my.cnf配置文件中，加入以下几行： 1234567[client]port=3306socket=/tmp/mysql.sockdefault-character-set=utf8mb4host=localhostuser=数据库用户password='数据库密码' 利用mysql_config_editor安全登录工具 生成加密文件： 1234567# mysql_config_editor set --login-path=local --host=192.168.1.190 --user=root --password参数说明：--login-path 标识--host 登录数据库的主机ip--user 登录数据库的用户名--password 要设置的密码# ll ~/.mylogin.cnf 使用加密文件登录： 1# mysql --login-path=local 查看当前主机上的加密文件： 1# mysql_config_editor print --all 删除某个加密登陆： 12# mysql_config_editor remove --login-path=remote# mysql_config_editor print --all 重置所有： 1# mysql_config_editor reset 利用环境变量MYSQL_PWD 12# export MYSQL_PWD=666666 密码# mysql -uroot -e 'select count(*) from mysql.user;' 不需要-p参数 将警告输出到null 1# mysql -uroot -p123456 -e 'show grants;' 2&gt;/dev/nul 2是标准出错]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux存储之LVM技术]]></title>
    <url>%2F2018%2F06%2F17%2Flinux-lvm%2F</url>
    <content type="text"><![CDATA[本文主要介绍Linux存储技术中的LVM的概念和操作方法。 1. 概述LVM全称是Logical Volume Manager，即逻辑卷管理器。它是Linux环境下对磁盘分区进行管理的一种机制；它可以将多个物理分区整合在一起，并且可以根据实际需要动态调整文件系统空间。 2. LVM的相关概念(1) 物理卷(Physical Volume) 物理卷是组成LVM的最底层的元素，即Linux上的物理分区。 (2) 卷组(Volume Group) 将各个独立的PV组合起来形成的一个存储空间就称为VG，VG的大小就是整个LVM的大小。 (3) 逻辑卷(Logical Volume) 可以被用户格式化、挂载并提供数据存储的对象就是LV。 (4) 物理扩展块(Physical Extent) PE相当于Linux分区中的block，它是LVM的最小存储单位，默认为4M。 做成lvm的优势: 可以灵活变动大小 可以自定义设备名(物理卷也可以改名，使用udev） 可以做线型(linear),条带(stripe),镜像(mirror) 可以做lvm快照 3. LVM基本操作 创建PV 12345678910111213# pvcreate /dev/md0 Physical volume "/dev/md0" successfully created# pvcreate /dev/md1 Physical volume "/dev/md1" successfully created# pvcreate /dev/md10 Physical volume "/dev/md10" successfully created查看相关信息的命令 pvscan pvdisplay pvs删除pv的命令 pvremove /dev/md10# pvpvchange pvcreate pvmove pvresize pvscanpvck pvdisplay pvremove pvs pv.sh 划分vg 12345678910111213141516171819# vgcreate vg01 /dev/md10 Volume group "vg01" successfully created # vgextend vg01 /dev/md0 Volume group "vg01" successfully extended# vgextend vg01 /dev/md1 Volume group "vg01" successfully extended补充：vgcreate -s 指定PE的大小查看相关信息的命令vgscan vgdisplay vgs# vgs VG #PV #LV #SN Attr VSize VFree vg01 3 0 0 wz--n- 4.99G 4.99G# vgreduce vg01 /dev/md0 Removed "/dev/md0" from volume group "vg01"vgreduce跟vgextend是相反的，是在vg里移除pv移除vg的命令是vgremove，它是和vgcreate相反 把vg划分为逻辑卷(线性卷linear) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# lvcreate -L 1000M -n lv01 vg01 --L指定大小，n指定lv的名字 Logical volume "lv01" created# lvcreate -l 250 -n lv02 vg01 --l指定PE的个数，n指定lv的名字 Logical volume "lv02" created # lvcreate -L 1001M -n lv03 vg01 --指定为1001M，它会自动做成1004M，要是PE的倍数 Rounding up size to full physical extent 1004.00 MB Logical volume "lv03" created# ls /dev/vg01/ -llrwxrwxrwx 1 root root 21 May 7 14:14 lv01 -&gt; /dev/mapper/vg01-lv01lrwxrwxrwx 1 root root 21 May 7 14:15 lv02 -&gt; /dev/mapper/vg01-lv02# ls /dev/mapper/ -lbrw-rw---- 1 root disk 253, 0 May 7 14:14 vg01-lv01brw-rw---- 1 root disk 253, 1 May 7 14:15 vg01-lv02# mkfs.ext4 /dev/vg01/lv01# mkfs.ext4 /dev/vg01/lv02# mount /dev/vg01/lv01 /mnt/# mount /dev/vg01/lv02 /media/# df -h | tail -4/dev/mapper/vg01-lv01 985M 18M 918M 2% /mnt/dev/mapper/vg01-lv02 985M 18M 918M 2% /media# echo '12345' &gt; /mnt/1# echo '678910' &gt; /media/2 查看的相关参数为lvscan lvdisplay# lvscan ACTIVE '/dev/vg01/lv01' [1000.00 MB] inherit ACTIVE '/dev/vg01/lv02' [1000.00 MB] inherit移除lv使用lvremove完全删除lvm，就要先lvremove,再vgremove，最后pvremove# vgs VG #PV #LV #SN Attr VSize VFree vg01 3 2 0 wz--n- 4.99G 3.04G# lvcreate -l 50%VG -n lv03 vg01 --创建lv03，大小为vg01的一半# lvcreate -l 100%FREE -n lv04 vg01 --把剩下的所有空间都分配给新创建的lv04# lvs --使用lvs验证 LV VG Attr LSize Origin Snap% Move Log Copy% Convert lv01 vg01 -wi-ao 1000.00M lv02 vg01 -wi-ao 1000.00M lv03 vg01 -wi-a- 2.49G lv04 vg01 -wi-a- 556.00M使用lvremove把上面的四个卷给移除，再来创建条状卷# lvremove vg01 --移除四个卷 Do you really want to remove active logical volume lv01? [y/n]: y Logical volume "lv01" successfully removedDo you really want to remove active logical volume lv02? [y/n]: y Logical volume "lv02" successfully removedDo you really want to remove active logical volume lv03? [y/n]: y Logical volume "lv03" successfully removedDo you really want to remove active logical volume lv04? [y/n]: y Logical volume "lv04" successfully removed Volume group "lv01" not found当您创建条状逻辑卷时，请使用 lvcreate 命令的 -i 参数指定条带的数目。这取决于逻辑卷要进行条带化的物理卷数目。条带的数目不能超过卷组中物理卷的数目（除非使用 --alloc anywhere 参数）如果构成逻辑卷的基本物理设备的大小不同，条状卷的最大容量由最小的基本设备决定。例如，在有两个分支条状卷中，其容量最大为较小设备的两倍。在有三个分支的条状卷中，其容量是最小设备的三倍条带卷的大小由最小的PV和创建命令的-i参数(条带数)来决定以这个为例 PV VG Fmt Attr PSize PFree /dev/md0 vg01 lvm2 a-- 2.00g 2.00g /dev/md1 vg01 lvm2 a-- 1020.00m 1020.00m /dev/md10 vg01 lvm2 a-- 2.00g 2.00g因为有三个PV,所以用-i 3实现三个条带;那么最大大小为1020*3=3060M 创建条带卷 1234# lvcreate -L 3060M -i3 -n stripe_lv_01 vg01 Logical volume "stripe_lv_01" created 可以对其格式化，再用dd和iostat来做测试(但测试的结果比较复杂,因为我是几种不同的raid做的条带卷) 镜像卷 当您创建一个镜像卷时，您可使用 lvcreate 命令的 -m 参数来指定数据的备份数目。指定 -m1 生成一个镜像，也就是生成两个文件系统副本：一个线性逻辑卷加上一个副本。同样的，指定 -m2 会生成两个镜像，也就是生成三个文件系统副本。 镜像卷的大小由最小的PV和副本数（也就是-m后接的数字)来决定 以这个为例 PV VG Fmt Attr PSize PFree /dev/md0 vg01 lvm2 a– 2.00g 2.00g /dev/md1 vg01 lvm2 a– 1020.00m 1020.00m /dev/md10 vg01 lvm2 a– 2.00g 2.00g 如果-m 1，那么他会选md0和md10这两个来做镜像，所以最大大小为2G 如果-m 2,那么他会选这三个一起来做，最大大小为1020M 不能-m 3或者更大;因为我这里只有三个PV 12345678910111213141516171819202122232425262728293031323334353637383940414243以下面的为例# pvs PV VG Fmt Attr PSize PFree /dev/sdb13 vg01 lvm2 a- 964.00M 964.00M /dev/sdb14 vg01 lvm2 a- 964.00M 964.00M /dev/sdb15 vg01 lvm2 a- 964.00M 964.00M# vgs VG #PV #LV #SN Attr VSize VFree vg01 3 0 0 wz--n- 2.82G 2.82G再次创建镜像卷，成功创建# lvcreate -n lv_mirror -L 300M -m 1 vg01 Logical volume "lv_mirror" created# ls /dev/mapper/control vg01-lv_mirror_mimage_0 vg01-lv_mirror_mlogvg01-lv_mirror vg01-lv_mirror_mimage_1格式化这个镜像卷，并挂载# mkfs.ext3 /dev/mapper/vg01-lv_mirror# mount /dev/mapper/vg01-lv_mirror /media/# df -h/dev/mapper/vg01-lv_mirror 291M 11M 266M 4% /media 测试镜像卷可用性# echo 123 &gt; /media/123# cat /media/123123破坏其中一个物理卷。 # dd if=/dev/zero of=/dev/sdb13 或者 # mkfs.ext3 /dev/sdb13pvs 检测出有物理卷被损坏,找不到uuid但数据仍然可以正常访问# cat /media/123123可以对其格式化，再用dd和iostat来做测试(但测试的结果比较复杂,因为我是几种不同的raid做的条带卷) 关于三种卷之间的转换: 12345678把线性卷转化成镜像卷# lvconvert -m 1 vg01/lv_linear --速度较慢 把镜像卷转化成线性卷# lvconvert -m 0 vg01/lv_mirror --速度较快实现总结：(1) 如果物理做了raid10，那么就可以不做条带和镜像卷了，只有线性卷就可以了(2) 如果物理没做raid，那么你希望提高IO性能或高可用，则可以使用条带或镜像卷 4. LVM扩容先考虑vg是否还有空间去扩容，如果没有，那么要先扩容vg,使用vgextend 12345678910111213141516171819202122# lvextend -L 1.5g /dev/vg01/lv01 Extending logical volume lv01 to 1.50 GB Logical volume lv01 successfully resized下面两种写法也可以# lvextend -L +500M /dev/vg01/lv01# lvextend -l +125 /dev/vg01/lv01# df -h/dev/mapper/vg01-lv01985M 18M 918M 2% /mnt 查看已经挂载的大小，没有变化# resize2fs /dev/vg01/lv01 再使用这个命令去在线同步resize2fs 1.39 (29-May-2006)Filesystem at /dev/vg01/lv01 is mounted on /mnt; on-line resizing requiredPerforming an on-line resize of /dev/vg01/lv01 to 393216 (4k) blocks.The filesystem on /dev/vg01/lv01 is now 393216 blocks long.# df -h/dev/mapper/vg01-lv011.5G 18M 1.4G 2% /mnt 再次查看,已经挂载的lv扩大了，并且数据没有影响 5. LVM缩小做缩小操作之前，都要去验证查看一下数据的大小，缩小时不要缩到比已经存在的数据量还要小(数据库内的表空间缩小也是一样要先查看已有数据大小） 1234567891011121314151617181920212223242526272829303132333435363738394041424344# resize2fs /dev/vg01/lv01 1g --这样去缩小的话，报错已经mount了resize2fs 1.39 (29-May-2006)Filesystem at /dev/vg01/lv01 is mounted on /mnt; on-line resizing requiredOn-line shrinking from 393216 to 262144 not supported.# umount /mnt/# resize2fs /dev/vg01/lv01 1g --umount后再使用resize2fs命令，要求先去e2fsck检测resize2fs 1.39 (29-May-2006)Please run 'e2fsck -f /dev/vg01/lv01' first.# e2fsck -f /dev/vg01/lv01 e2fsck 1.39 (29-May-2006)Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary information/dev/vg01/lv01: 12/192000 files (8.3% non-contiguous), 10517/393216 blocks# resize2fs /dev/vg01/lv01 1g 检测后再使用resize2fs命令缩小，并挂载查看大小是否缩小resize2fs 1.39 (29-May-2006)Resizing the filesystem on /dev/vg01/lv01 to 262144 (4k) blocks.The filesystem on /dev/vg01/lv01 is now 262144 blocks long.# lvscan ACTIVE '/dev/vg01/lv01' [1.50 GB] inherit 但这里查看的还是1.5g ACTIVE '/dev/vg01/lv02' [1000.00 MB] inherit# lvreduce -L 1g /dev/vg01/lv01 所以lvreduce也要做 WARNING: Reducing active logical volume to 1.00 GB THIS MAY DESTROY YOUR DATA (filesystem etc.)Do you really want to reduce lv01? [y/n]: y Reducing logical volume lv01 to 1.00 GB Logical volume lv01 successfully resized# lvscan ACTIVE '/dev/vg01/lv01' [1.00 GB] inherit --OK ACTIVE '/dev/vg01/lv02' [1000.00 MB] inherit# mount /dev/vg01/lv01 /mnt/# df -h/dev/mapper/vg01-lv02985M 18M 918M 2% /media 缩小了 6. lvm 快照功能(1) 快照创建的速度非常快，不需要停止生产环境 (2) 快照的大小是存储差异数据，或是快照时间点的状态，不需要和lv同大小 (3) 它可以用于一些特殊的情况，比如数据库备份，或者批量复制虚拟机（不关闭虚拟机的情况下，克隆是需要关闭或暂停虚拟机的),虚拟机做快照等 123456789101112131415161718192021222324252627282930313233343536373839404142434445# dd if=/dev/zero of=/media/10m bs=1M count=10# dd if=/dev/zero of=/media/20m bs=1M count=20# dd if=/dev/zero of=/media/30m bs=1M count=30# ls /media/ -ltotal 61532-rw-r--r-- 1 root root 10485760 May 7 15:18 10m-rw-r--r-- 1 root root 20971520 May 7 15:18 20m-rw-r--r-- 1 root root 31457280 May 7 15:18 30mdrwx------ 2 root root 16384 May 7 14:17 lost+found# lvcreate -s -L 100m -n snap01 /dev/vg01/lv02 --L参数指定的大小不是快照大小，它类似于一个快照存活的时间（由源的改变来定义存活时间的长短。源增加多少，这个100M‘时间‘就会被使用多少，源删除，这个100M时间只会被增加一点点，因为删除只记录它的一个innode失效。但注意，快照的内容不会跟着改变。 Logical volume "snap01" created# ls /dev/vg01/snap01 /dev/vg01/snap01# mkdir /snap# mount /dev/vg01/snap01 /snap/# ls /snap/ --快照的内容10m 20m 30m lost+found# dd if=/dev/zero of=/media/50m bs=1M count=50--在源目录加一个50M的文件# ls /snap/ --快照的内容不会跟着变10m 20m 30m lost+found# lvs LV VG Attr LSize Origin Snap% Move Log Copy% Convert lv01 vg01 -wi-ao 1.00G lv02 vg01 owi-ao 1000.00M snap01 vg01 swi-ao 100.00M lv02 50.48 --但是这个snap%会发现由几乎为0变化到50%下面再可以继续做试验：1，在源删除一个文件，再使用lvs查看 %snap只会增加一点点2，当%snap用完了100%，则快照失效。umount和mount快照都会出问题3, 快照的内容不会跟着源改变# lvremove /dev/vg01/snap01 --快照的移除Do you really want to remove active logical volume snap01? [y/n]: y Logical volume "snap01" successfully removed]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux存储之RAID技术]]></title>
    <url>%2F2018%2F06%2F17%2Flinux-raid%2F</url>
    <content type="text"><![CDATA[本文主要介绍Linux存储技术中的RAID的概念和操作方法。 1. RAID概念 RAID（Redundant Array of Inexpensive Disks）称为廉价磁盘冗余阵列。RAID的基本想法是把多个便宜的小磁盘组合到一起，成为一个磁盘组，使性能达到或超过一个容量巨大、价格昂贵的磁盘。 目前 RAID技术大致分为两种：基于硬件的RAID技术和基于软件的RAID技术。 本文介绍的是软RAID。 2. RAID级别raid 0 读写性能佳，坏了其中一块，数据挂掉，可靠性低（stripe条带化），磁盘利用率100％ ​ A B ​ 1 2 ​ 3 4 raid 1 镜像备份（mirror)，同一份资料完整的保存在多个磁盘上，写的性能不佳，可靠性高，读的性能还行，磁盘利用率50% ​ A B ​ 1 1 ​ 2 2 ​ 3 3 ​ 4 4 raid 5 由多块磁盘做raid 5，磁盘利用率为n-1/n, 其中一块放校验数据，允许坏一块盘，数据可以利用校验值来恢复 ​ disk 1 disk 2 disk 3 ​ 数据 数据 校验 ​ 检验 数据 数据 ​ 数据 检验 数据 raid 10 先做raid1，再做raid0 raid01 先做raid0，再做raid1 3. 软RAID实现使用vmware或者kvm直接在线加8个1G大小的硬盘 linear 线型 stripe 条带 mirror 镜像 创建raid 0 12# mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdb /dev/sdcmdadm: array /dev/md0 started. 创建过程中可以用另一终端cat /proc/mdstat去查看正在创建的状态信息 1234# mkfs.ext4 /dev/md0# mount /dev/md0 /mnt/# df -h |grep mnt# cat /proc/mdstat 创建raid 1 1234# mdadm --create /dev/md1 --level=1 --raid-devices=2 /dev/sdd /dev/sde# mkfs.ext4 /dev/md1# mount /dev/md1 /media/# df -h |grep md 对上面的raid0和raid1的一个写性能使用dd命令进行测试，下面命令可以多测几次 12# dd if=/dev/zero of=/mnt/aaa bs=1M count=1000# dd if=/dev/zero of=/media/bbb bs=1M count=1000 测试的结果是raid0写性能比raid1要好 1# yum install sysstat -y 验证raid0，在做raid0的两个盘上查看io情况 终端1：iostat 2 两秒一次查看所有的盘上的IO情况 终端2: dd if=/dev/zero of=/mnt/aaa bs=1M count=1000 可以看到两个盘上都有写的io,并且/dev/sdb和/dev/sdc的IO一样,总和才等于/dev/md0的IO;验证了raid0的功能(条带) 验证raid1，在做raid1的两个盘上查看io情况 终端1：iostat 2 两秒一次查看所有的盘上的IO情况 终端2: dd if=/dev/zero of=/media/aaa bs=1M count=1000 可以看到两个盘上都有写的io,并且/dev/sdd和/dev/sde的IO一样,并且也等于/dev/md1的IO;验证了raid1的功能(镜像) 创建raid5 12345678910# mdadm --create /dev/md5 --level=5 --raid-devices=4 /dev/sdf /dev/sdg /dev/sdh /dev/sdimdadm: array /dev/md5 started.# watch cat /proc/mdstat --这里监控一下它们盘之间的数据同步；等它们同步完毕再进行下面的格式化# mkfs.ext4 /dev/md5# mount /dev/md5 /misc/# df -h |grep md/dev/md0 2.0G 36M 1.9G 2% /mnt --raid 0利用率为100%/dev/md1 1008M 18M 940M 2% /media --raid 1利用率为50%/dev/md5 3.0G 69M 2.8G 3% /misc --raid 5利用率为n-1/n,在这里就是3/4# cat /proc/mdstat 验证raid5，在做raid5的四个盘上查看io情况 终端1：iostat 2 两秒一次查看所有的盘上的IO情况 终端2: dd if=/dev/zero of=/misc/aaa bs=1M count=1000 4. RAID启停123456789# vim /etc/mdadm.conf 手动编写raid的配置文件，此文件不存在，要手动建立，并写上DEVICES /dev/sdb /dev/sdc /dev/sdd /dev/sde /dev/sdf /dev/sdg /dev/sdh /dev/sdi 把做了raid的分区写上来。或者写成DEVICES /dev/sd[bcdefghi]。但不能写成DEVICES /dev/sd&#123;b,c,d,e,f,g,h,i&#125;# mdadm --detail --scan &gt;&gt; /etc/mdadm.conf 扫描当前raid的信息，并追加到配置文件里# cat /etc/mdadm.conf DEVICES /dev/sdb /dev/sdc /dev/sdd /dev/sde /dev/sdf /dev/sdg /dev/sdh /dev/sdiARRAY /dev/md0 level=raid0 num-devices=2 metadata=0.90 UUID=84209045:9c03c4cb:7f755b8d:cc471294ARRAY /dev/md1 level=raid1 num-devices=2 metadata=0.90 UUID=4e62fdc1:6c2a652f:fb72c05d:356d5c76ARRAY /dev/md5 level=raid5 num-devices=4 metadata=0.90 UUID=c3c1f37b:9fba8a89:a711dc6c:01a5ddb3 停止raid设备 123456789101112先umount 已经挂载的raid设备# umount /mnt/# umount /media/# umount /misc/然后使用命令停止# mdadm --stop /dev/md0mdadm: stopped /dev/md0# mdadm --stop /dev/md1mdadm: stopped /dev/md1# mdadm --stop /dev/md5mdadm: stopped /dev/md5 启动raid设备” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162(1) 有/etc/mdadm.conf配置文件的情况下# mdadm -A /dev/md0 mdadm: /dev/md0 has been started with 2 drives.# mdadm -A /dev/md1mdadm: /dev/md1 has been started with 2 drives.# mdadm -A /dev/md5mdadm: /dev/md5 has been started with 4 drives.# cat /proc/mdstat --再查看，就有信息了，并且raid里的数据还在(2) 没有配置文件的情况下，手动把设备名写上就可以了# mdadm -A /dev/md0 /dev/sd&#123;b,c&#125;mdadm: /dev/md0 has been started with 2 drives.# mdadm -A /dev/md1 /dev/sd&#123;d,e&#125;mdadm: /dev/md1 has been started with 2 drives.# mdadm -A /dev/md5 /dev/sd&#123;f,g,h,i&#125;mdadm: /dev/md5 has been started with 4 drives.(3) 如果连设备名都不知道，可以去查看每个设备的raid信息，使用uuid把raid设备重新组合# mdadm -E /dev/sdf/dev/sdf: Magic : a92b4efc Version : 0.90.00 UUID : b091e16b:f8df9671:465755db:c640595b --UUID,同一个raid里每个磁盘查看的都是这个值 Creation Time : Sat May 7 11:23:52 2011 Raid Level : raid5 Used Dev Size : 1048512 (1024.11 MiB 1073.68 MB) Array Size : 3145536 (3.00 GiB 3.22 GB) Raid Devices : 4 Total Devices : 4Preferred Minor : 5 Update Time : Sat May 7 11:42:09 2011 State : clean Active Devices : 4Working Devices : 4 Failed Devices : 0 Spare Devices : 0 Checksum : facef367 - correct Events : 2 Layout : left-symmetric Chunk Size : 64K Number Major Minor RaidDevice Statethis 0 8 80 0 active sync /dev/sdf 0 0 8 80 0 active sync /dev/sdf 1 1 8 96 1 active sync /dev/sdg 2 2 8 112 2 active sync /dev/sdh 3 3 8 128 3 active sync /dev/sdi# mdadm -A --uuid=b091e16b:f8df9671:465755db:c640595b /dev/md5 mdadm: /dev/md5 has been started with 4 drives.上面组合后的名字可以随意写，甚至是不存在的一个名字，相当于是重新组合 5. 软raid的热插拔实验模拟raid中其中一块盘故障 123456789101112131415161718192021222324252627282930313233343536# mdadm /dev/md5 --fail /dev/sdfmdadm: set /dev/sdf faulty in /dev/md5--使用--fail对raid中其中一块盘打一个fail标记# cat /proc/mdstat Personalities : [raid0] [raid1] [raid6] [raid5] [raid4] md5 : active raid5 sdf[4](F) sdi[3] sdh[2] sdg[1]--有个F标记 3145536 blocks level 5, 64k chunk, algorithm 2 [4/3] [_UUU] md1 : active raid1 sdd[0] sde[1] 1048512 blocks [2/2] [UU] md0 : active raid0 sdb[0] sdc[1] 2097024 blocks 64k chunks# mdadm /dev/md5 --remove /dev/sdfmdadm: hot removed /dev/sdf热移除故障磁盘# mdadm /dev/md5 --add /dev/sdj --增加一块新的磁盘上去mdadm: re-added /dev/sdj--刚增加完后，机器负载较高，因为现在它在对新盘同步数据# cat /proc/mdstat Personalities : [raid0] [raid1] [raid6] [raid5] [raid4] md5 : active raid5 sdj[4] sdi[3] sdh[2] sdg[1] 3145536 blocks level 5, 64k chunk, algorithm 2 [4/3] [_UUU] [=====&gt;...............] recovery = 29.2% (307840/1048512) finish=0.0min speed=153920K/sec --这里可以看到在同步中 md1 : active raid1 sdd[0] sde[1] 1048512 blocks [2/2] [UU] md0 : active raid0 sdb[0] sdc[1] 2097024 blocks 64k chunks 同步完成后，查看数据还在； 6. 删除raid123456789101112131415161718192021222324(1) 第一步# umount(2) 第二步# mdadm /dev/md5 --fail /dev/sdf --remove /dev/sdfmdadm: set /dev/sdf faulty in /dev/md5mdadm: hot removed /dev/sdf# mdadm /dev/md5 --fail /dev/sdg --remove /dev/sdgmdadm: set /dev/sdg faulty in /dev/md5mdadm: hot removed /dev/sdg# mdadm /dev/md5 --fail /dev/sdh --remove /dev/sdhmdadm: set /dev/sdh faulty in /dev/md5mdadm: hot removed /dev/sdh# mdadm /dev/md5 --fail /dev/sdi --remove /dev/sdimdadm: set /dev/sdi faulty in /dev/md5mdadm: hot removed /dev/sdi(3) 第三步# mdadm --stop /dev/md5mdadm: stopped /dev/md5(4) 第四步直接用fdisk删除分区，或者用下面命令擦除superblock# mdadm --misc --zero-superblock /dev/sdf# mdadm --misc --zero-superblock /dev/sdg# mdadm --misc --zero-superblock /dev/sdh# mdadm --misc --zero-superblock /dev/sdi]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下自动批量部署操作系统]]></title>
    <url>%2F2018%2F06%2F15%2Flinux-ks%2F</url>
    <content type="text"><![CDATA[本文主要介绍Linux下使用kickstart进行自动批量安装系统。 1. kickstart简介Kickstart是一种无人值守的安装方式。它的工作原理是在安装过程中记录典型的需要人工干预填写的各种参数，这些参数都记录在ks.cfg的文件中， 安装程序按照预先设置好的参数进行部署操作系统。等安装完毕，安装程序会根据ks.cfg中的设置重启系统，并结束安装。 kickstart是基于pxe(preboot execute environment)技术，pxe是intel公司的技术，工作server/client的网络模式，支持客户端从服务端下载软件，再使用tftp(trival file tranfer protocol) 协议下载一个启动软件包到客户端内存中执行。 要求的技术和服务： (1) http服务器或者用nfs,ftp三种协议之一 共享安装光盘目录文件(2) tftp服务器 共享启动引导文件(3) dhcp服务器 客户端获取IP，网关，DNS指向，主机名，NIS域，NTP(4) kickstart程序生成的ks.cfg配置文件 2. 实践 第一步，搭建安装源 1234# yum install httpd -y 安装httpd# mkdir /var/www/html/iso 创建一个目录# mount /opt/packs/CentOS-6.5-x86_64-bin-DVD1.iso /var/www/html/iso -o loop 将光盘挂载# service httpd start 要保证可以通过http方式获取光盘里的内容 第二步，配置tftp服务器 1234567891011121314151617# yum install tftp-server 安装tftp# vim /etc/xinetd.d/tftpservice tftp&#123; socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -t -s -v /var/lib/tftpboot 启动参数改为-t -s -v disable = no yes改为no per_source = 11 cps = 100 2 flags = IPv4&#125;# service xinetd start# netstat -ntlup |grep :69 确认tftp启动了 第三步，配置pxe启动文件 12345678910111213# yum install syslinux -y# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/# cp /var/www/html/iso/isolinux/* /var/lib/tftpboot/ # mkdir /var/lib/tftpboot/pxelinux.cfg# cp /var/www/html/iso/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default# vim /var/lib/tftpboot/pxelinux.cfg/defaultdefault linux-rzxprompt 1timeout 3label linux-rzx kernel vmlinuz append initrd=initrd.img ks=http://192.168.1.99/ks/ks.cfg 第四步，搭建DHCP服务器 1234567891011121314151617181920# yum install dhcp -y# cp /usr/share/doc/dhcp-4.1.1/dhcpd.conf.sample /etc/dhcp/dhcpd.conf# vim /etc/dhcp/dhcpd.conflog-facility local7;next-server 192.168.1.99;filename "/var/lib/tftpboot/pxelinux.0";allow bootp;allow booting;subnet 192.168.1.0 netmask 255.255.255.0 &#123; range 192.168.1.50 192.168.1.100; option domain-name-servers 192.168.1.1; option routers 192.168.1.1; option broadcast-address 192.168.1.255; default-lease-time 600; max-lease-time 7200;&#125;# /etc/init.d/dhcpd restart 第五步，配置kickstart 12# yum install system-config-kickstart 安装kickstart的图形配置工具# system-config-kickstart 运行该命令生成ks.cfg文件 这里说明一点：如果系统中没有安装图形，是不能运行system-config-kickstart的。 生成ks.cfg文件之后，将其放到Apache的数据目录，以便在安装系统时，可以下载到。 12# mkdir /var/www/html/ks/# ks.cfg /var/www/html/ks/ 第六步，安装 服务器启动时，选择网络启动方式优先。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下远程拷贝时无需输入密码]]></title>
    <url>%2F2018%2F06%2F13%2Flinux-nopass-copy%2F</url>
    <content type="text"><![CDATA[本文主要介绍Linux系统中，远程拷贝文件时无需输入密码来拷贝的一种简单办法。我们在远程拷贝文件时，尤其是不同地区的服务器之间拷贝数据，一般是使用scp或者rsync来拷贝。这两个命令都需要输入密码。一般来说，有三种办法来实现无密码拷贝。(1)SSH等效性建立信任关系(2)使用expect脚本来自动输入密码(3)使用sshpass工具来自动输入密码本文重点介绍sshpass工具来实现，这个工具比较简单。 1. sshpass命令如果系统中没有sshpass命令，则通过如下命令可以安装：1# yum -y install sshpass sshpass命令的使用方法：12# sshpass -p 123456 ssh 192.168.1.100 -p参数是服务器192.168.1.100的密码，这样就可以直接登录了# sshpass -f password.txt ssh 192.168.1.100 -f参数是file，密码文件，默认读取文件的第一行作为密码 2. sshpass实现远程拷贝123# sshpass -f password.txt scp -r /opt/packs/xxx.iso root@192.168.1.100:/root/packs/# sshpass -f password.txt rsync -a /opt/packs/xxx.iso root@192.168.1.100:/root/packs/# nohup sshpass -f password.txt rsync -a /opt/packs/xxx.iso root@192.168.1.100:/root/packs/ &amp; 也可以使用nohup在后台跑 这里建议使用sshpass的-f参数来存放密码，然后执行1# chmod 600 password.txt 这样只有root才可以读写，保证了安全性。-p直接在命令行输入密码不安全。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统备份与还原]]></title>
    <url>%2F2018%2F06%2F12%2Flinux-system-backup%2F</url>
    <content type="text"><![CDATA[本文主要介绍centos系统的备份和还原。我们在使用Windows时，可以使用ghost工具对系统进行备份，那么Linux系统是如何备份的呢 1. 备份系统在linux系统中，有一句话叫做一切都是文件，既然是文件，我们就可以通过打包的方式来备份。 使用root身份登录系统，进行打包操作。 12345678# tar cvpzf /backup.tgz –exclude=/proc –exclude=/lost+found –exclude=/backup.tgz –exclude=/mnt –exclude=/sys –exclude=/sys /参数说明：c 按照man手册，直译创建一个新的存档，意思是打包文件backup.tgz不存在，需要创建v 显示打包过程和细节p 保留文件的权限z gzip格式压缩，和windows上的rar格式或zip格式差不多f 文件，cf一起的意思是创建文件exclude 是排除那些文件不打包进去 上面的命令将/下的所有东西打成一个包，有些系统上动态的文件可以不用打包，排除出去，比如：/proc，/sys。也可以把不用备份的文件排除出去。 2. 系统还原在进行恢复系统的操作时一定要小心！如果你不清楚自己在做什么，那么你有可能把重要的数据弄丢，请务必小心！ 切换到root用户，并把文件“backup.tgz”拷贝到分区的根目录下。 1# tar xvpfz /backup.tgz -C / 恢复命令结束时，你的工作还没完成，别忘了重新创建那些在备份时被排除在外的目录： 1234# mkdir proc# mkdir lost+found# mkdir mnt# mkdir sys 保险起见，最好是执行一下如下命令： 1# restorecon -Rv / restorecon命令是用来恢复文件的SELinux配置信息的。 最后重启服务器，重新启动时观察一下，有没有服务没有起来。 3. 还原到其他的Linux中有时候会出现这种情况，备份的Linux系统已经损坏，比如硬盘坏了，上面的备份文件还有，那么是否可以恢复呢，答案是肯定的。 重新准备一台服务器，最好是分区、系统版本和损坏的服务器是一致的，安装好相同版本的Linux系统。将备份文件backup.tgz拷贝到新的服务器中。 12# mkdir /mnt/backup/# awk 'BEGIN &#123; cmd="cp -ari /mnt/backup/* /"; print "n" |cmd; &#125;' 上面的命令是”cp -ari /mnt/backup/* /“，意思是拷贝所有的备份文件，将/下的目录进行覆盖。print “n”的意思是同名文件不覆盖。这样做就是将老系统中的文件复制到新系统，不覆盖已经存在的文件。 那么为什么不能覆盖呢？每个Linux系统中有一些唯一的信息不能覆盖，否则系统会坏掉。比如： 1234567# blkid/dev/sda5: UUID="5d938847-6503-40cf-845d-a85777d4d1e1" TYPE="ext4" /dev/sda1: UUID="86215e74-789c-4a32-ad2a-7d2a1a06a587" TYPE="ext4" /dev/sda2: UUID="1031afbe-2bf8-474c-9d3f-93a77d5751df" TYPE="ext4" /dev/sda3: UUID="83898300-4d9d-41de-951a-62896cde5025" TYPE="ext4" /dev/sda6: UUID="381b6c24-de6a-4d01-8382-9b3bb3a9ecc3" TYPE="ext4" /dev/sda7: UUID="c0793320-2302-4018-8482-130fbc4dca06" TYPE="swap" 每个系统的分区都有一个UUID，这个是唯一的，覆盖之后就会出问题。 123456789101112131415161718# cat /etc/fstab ## /etc/fstab# Created by anaconda on Tue Dec 22 15:16:37 2015## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#UUID=5d938847-6503-40cf-845d-a85777d4d1e1 / ext4 defaults 1 1UUID=1031afbe-2bf8-474c-9d3f-93a77d5751df /appslog ext4 defaults 1 2UUID=86215e74-789c-4a32-ad2a-7d2a1a06a587 /boot ext4 defaults 1 2UUID=83898300-4d9d-41de-951a-62896cde5025 /opt ext4 defaults 1 2UUID=381b6c24-de6a-4d01-8382-9b3bb3a9ecc3 /usr ext4 defaults 1 2UUID=c0793320-2302-4018-8482-130fbc4dca06 swap swap defaults 0 0tmpfs /dev/shm tmpfs defaults 0 0devpts /dev/pts devpts gid=5,mode=620 0 0sysfs /sys sysfs defaults 0 0proc /proc proc defaults 0 0 系统中的fstab中用到了UUID，覆盖了文件会导致系统启动不了。 然后执行： 1# restorecon -Rv / 这一步是必须的，否则重启系统会报错。 最后就是观察重启系统时，是否有服务没启动，需要手动将其启动。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux网络工具]]></title>
    <url>%2F2018%2F06%2F10%2Flinux-net-tools%2F</url>
    <content type="text"><![CDATA[本文主要介绍Linux系统中常用的网络工具。 1. curl命令curl 命令行访问URL的工具 12345678910111213141516171819202122# curl http://www.baidu.com 直接将百度网页的源码输出到屏幕上# curl http://www.baidu.com –o baidu.html 将百度网页的源码保存起来# curl -O http://www.linux.com/hello.sh 将hello.sh文件下载下来# curl -# -O http://www.linux.com/dodo1.JPG 显示下载进度条# curl -C -O http://www.linux.com/dodo1.JPG 断点续传# curl -o /dev/null -s -w %&#123;http_code&#125; www.baidu.com 测试网页返回值，非常有用# curl -o /dev/null -s -w %&#123;http_code&#125;:%&#123;http_connect&#125;:%&#123;content_type&#125;:%&#123;time_namelookup&#125;:%&#123;time_redirect&#125;:%&#123;time_pretransfer&#125;:%&#123;time_connect&#125;:%&#123;time_starttransfer&#125;:%&#123;time_total&#125;:%&#123;speed_download&#125; digdeeply.org# curl -x 192.168.100.100:1080 http://www.linux.com -x参数是设置代理的# curl -I http://static.futunn.com/passport/images/global/logo_futunn-b9fab8d8f683775e9c3c5ade78e822ec.png -x 211.162.36.175:80# curl -I www.sina.com.cn -x 124.42.245.30:80# curl -I 124.42.245.30# curl -I 124.42.245.30 -H 'host:www.sina.com.cn'# curl -s -D header.txt http://www.linux.com -o /dev/null 保存访问网站的header信息# curl -I http://www.linux.com 在屏幕上显示header信息# curl -c cookie.txt http://www.linux.com 保存访问网站的cookie信息# curl -A "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)" http://www.linux.com 模仿浏览器# curl -e "www.abc.com" http://mail.linux.com 伪造referer# curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/ 上传文件# curl ip.cn# curl myip.ipip.net# curl ip.cip.cc 2. nmap命令Nmap 是一款开放源代码的 网络探测和安全审核的工具。 它的设计目标是快速地扫描大型网络 。 123456789101112131415161718192021# nmap -sP 192.168.1.0/24 使用ping检测192.168.1.0/24这个网段# nmap --iflist# nmap -e eth0 192.168.1.5 扫描ip开放的端口# nmap 192.168.1.1 -p 1-500 自定义扫描端口# nmap -sn 192.168.1.0/2 只进行主机发现，不进行端口扫描# nmap 192.168.1.1 -P0 端口扫描(Pn)# nmap 192.168.1.1-100 多个ip# nmap -F 192.168.1.* 多个ip，-F 快速扫描# nmap -sS 192.168.1.153 Tcp SYN Scan (sS)# nmap -sT 192.168.1.153 Tcp connect() scan(sT)# nmap -sU 192.168.1.153 Udp scan(sU)# nmap -sF 192.168.1.153 FINscan(sF)# nmap -sV 192.168.1.153 版本检测(sV)# nmap 192.168.1.153 -p U:22,80,T:21-25,80,139,8080 TCP、UDP端口扫描# nmap --traceroute www.baidu.com 路由跟踪# nmap -O 192.168.1.153 操作系统# nmap -A 192.168.1.153 激进方式扫描，扫描端口和os# nmap -sV -p 22 -oG grep-output.txt 192.168.1.0/24 输出格式，可检索的# nmap -sV -p 22 -oA grep-output.txt 192.168.1.0/24 输出格式，-oA所有，可检索的、常规的和XML文件# nmap -sV -p 22 -oX grep-output.txt 192.168.1.0/24 输出格式，XML# nmap -sV -p 22 -oN grep-output.txt 192.168.1.0/24 输出格式，常规格式 3. nc命令 (1) 安装 1# yum install -y nc (2) 远程拷贝文件 1234server1：# nc -l 1234 &gt; test.txtserver2：# nc 192.168.1.3 &lt; test.txt (3) 传输目录 1234server1：# nc -l 1234 | tar xzv-server2：# tar czv- nginx | nc 192.168.48.47 1234 (4) 简单聊天工具 1234在192.168.1.2上： # nc -l 1234在192.168.1.3上： # nc 192.168.1.2 1234 (5) 端口扫描 1# nc -v -w 2 192.168.2.34 -z 21-24 (6) 克隆硬盘或分区 12# nc -l -p 1234 | dd of=/dev/sda# dd if=/dev/sda | nc 192.168.228.222 1234 4. wget命令wget是一个下载文件的工具 。 命令格式： wget [参数] [URL地址 ] wget下载单个文件 1# wget http://ftp.gnu.org/gnu/wget/wget-1.16.2.tar.gz 下载并以不同的文件名保存 1# wget http://ftp.gnu.org/gnu/wget/wget-1.16.2.tar.gz -o wget.tgz 限速下载 1# wget --limit-rate=300k http://ftp.gnu.org/gnu/wget/wget-1.16.2.tar.gz 断点续传 1# wget -c http://ftp.gnu.org/gnu/wget/wget-1.16.2.tar.gz 后台下载 1# wget -b http://ftp.gnu.org/gnu/wget/wget-1.16.2.tar.gz 测试下载链接 1# wget --spider http://ftp.gnu.org/gnu/wget/wget-1.16.2.tar.gz 复制整个网站（镜像） 1# wget --mirror --convert-links http://exampledomain.com 访问需要认证的HTTP或FTP页面 1# wget --user username --password pass URL 指定目录下载 1# wget -P /home/download http://ftp.gnu.org/gnu/wget/wget-1.16.2.tar.gz 下载目录中的所有文件 12345678910# wget -r -np -nd http://mirrors.163.com/centos/6/isos/x86_64/# wget -r -p -np -k http://mirrors.163.com/centos/6/isos/x86_64/参数说明：-r, --recursive 递归下载-k, --convert-links 让下载得到的 HTML 或 CSS 中的链接指向本地文件-m, --mirror -N -r -l inf --no-remove-listing 的缩写形式-np, --no-parent 不追溯至父目录-nd, --no-directories 不创建目录-l, --level=NUMBER 最大递归深度 (inf 或 0 代表无限制，即全部下载)-c, --continue 断点续传下载文件]]></content>
      <categories>
        <category>linux-basic</category>
      </categories>
      <tags>
        <tag>linux-basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统相关命令]]></title>
    <url>%2F2018%2F06%2F10%2Flinux-system%2F</url>
    <content type="text"><![CDATA[本文主要介绍Linux系统相关命令，比如关机，查看硬件信息等。 1. 关机命令12345678# shutdown -h now 关机# init 0 关机# telinit 0 关机# # shutdown -h hours:minutes &amp; 按预定时间关机# shutdown -c 取消按预定时间关闭系统# shutdown -r now 重启 # reboot 重启 # logout 注销 2. 硬件相关12345# dmidecode -q 硬件相关信息 # hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 # lscpu 查看CPU# lspci 查看主板# lsblk 查看磁盘分区 3. 网络命令 ifconfig命令 12345678# ifconfig 显示一个以太网卡的配置，常用选项：# ifconfig eth0# ifconfig eth0 down# ifconfig eth0 up# ifconfig eth0 192.168.1.99 broadcast 192.168.1.255 netmask 255.255.255.0# ifconfig eth0:0 192.168.1.100 netmask 255.255.255.0 添加虚拟网卡# ifup eth0 启用一个 'eth0' 网络设备 # ifdown eth0 禁用一个 'eth0' 网络设备 ip命令 12345678910# ip 网络配置工具，常用选项：# ip a# ip addr show# ip addr show dev eth0 查看服务器ip地址# ip -s link list# ip -s link ls eth0 查看接口统计(ethtool -S eth0)# ip route list 查看路由表# ip neigh list 查看邻居表（arp -an）# ip addr add 192.168.0.215/24 label eth0:1 dev eth0 添加虚拟网卡# ip addr del 192.168.0.215/24 label eth0:1 dev eth0 删除虚拟网卡 netstat命令 12345# netstat -an | grep LISTEN -a 显示所有socket，包括正在监听的, -n 以网络IP地址代替名称# netstat -ntlup 查看系统网络的状态信息，t=tcp，u=udp，p=程序名称，l=监听# netstat -s 按照各个协议分别显示其统计数据# netstat -i 显示网卡接口信息# netstat –r 显示关于路由表的信息(rount -n) 4. 系统监控和性能分析命令 iostat命令 12345# iostat 直接运行，显示所有设备负载情况# iostat 2 3 每2秒显示一次，总共显示3次# iostat -c 查看cpu# iostat -d 查看磁盘# iostat -d -x 1 x参数是详细信息 vmstat命令 123# vmstat 虚拟内存统计# vmstat 2 2 每2秒显示一次，总共显示2次# vmstat 2 2 -S m -S参数是单位，可以是k、m等 free命令 123# free 查看内存# free -m -m是单位# free -m -s 2 -s是时间，每2秒查看一次 dstat命令 12345# dstat 信息统计工具# dstat -n n是net# dstat -d d是disk# dstat -m m是memory# dstat -l l是load average 显示系统负载情况]]></content>
      <categories>
        <category>linux-basic</category>
      </categories>
      <tags>
        <tag>linux-basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文本文件处理(4)]]></title>
    <url>%2F2018%2F06%2F10%2Flinux-sed%2F</url>
    <content type="text"><![CDATA[本文主要介绍sed命令的用法。 1. awk简介Sed：Stream Editor 流式编辑器 又称行编辑器，每次只编辑一行。 2. 基本用法1# sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]... 选项与参数：-n：只显示sed匹配到的行。其余行不显示。-i：可以直接操作原文件。默认情况下sed不会改变原文件，但是-i选项可以修改原文件，此选项应慎用。-r：可以使用标准正则表达式。默认情况下sed只支持基本正则表达式，但是加上-r选项后则支持扩展正则表达式-e：可以同时执行多个命令常用格式：(1)Sed [options] ‘script’ input_file……(2)Sed [options] -f script_file input_file……(3)Sed [options] ‘ADDR1,ADDR2command’ input_file……(4)Sed [options] ‘/PATTERN/command’ input_file……(5)Sed ‘/PATTERN1/,/PATTERN2/command’ input_file…… 常用命令(command)如下： 打印p 123456789101112131415161718192021222324252627282930# sed -n '3p' /etc/passwd --打印第3行# sed -n '1,3p' /etc/passwd --打印第1到第3行# sed -n '1,$p' /etc/passwd# nl /etc/passwd | sed -n '5,7p' --打印第5到第7行# head -5 /etc/passwd |sed -ne '1p;4p' --打印第1行和第4行# nl /etc/passwd | sed -n '/root/p' --查找包含root的行# cat /etc/passwd | sed -n '/^root/p'# ifconfig eth1 | sed -n '2p' | awk -F: '&#123;print $2&#125;' | awk '&#123;print $1&#125;' --截取ip# head -5 /etc/passwd |sed -ne '/^[[:upper:]]/p;/^[a-z]/p' --分别打印大写字母开头的行和小写字母开头的行# head -5 /etc/passwd |sed -ne '/^[[:upper:]]/,/^[a-z]/p' --用正则表达式实现范围打印# head -5 /etc/passwd |sed -ne '/^[[:upper:]]/,/nologin$/p'# head -5 /etc/passwd |sed -n '/^[^[:blank:]]/p' --打印非空格开头的行下面三条都是把有Accepted关键字的行打印出来# awk '$0~"Accepted" &#123;print $0&#125;' /var/log/ssh.log # sed -n '/Accepted/p' /var/log/ssh.log # cat /var/log/ssh.log | grep Accepted比较awk# head -5 /etc/passwd |cat -n | sed -n '1,4p'# head -5 /etc/passwd |cat -n | awk 'NR&lt;5 &#123;print $0&#125;'# head -5 /etc/passwd |cat -n | sed -n '1p;3p;5p'# head -5 /etc/passwd |cat -n | awk 'NR==1 || NR==3 || NR==5 &#123;print $0&#125;'# head -5 /etc/passwd |cat -n | sed -n '/root/p;/daemon/p;/lp/p'# head -5 /etc/passwd |cat -n | awk '$0~"root" || $0~"daemon" || $0~"lp" &#123;print $0&#125;' 删除esed删除语法：sed ‘范围d’ file以行为单位删除，如果不指定范围，默认范围是整个文件。 123456789101112131415161718# sed '1d' /etc/passwd 删除第一行，第二行2d，第三行3d，以此类推，最后一行$d# sed '1,3d' /etc/passwd 删除第1行到第3行，中间是逗号# sed '1d;3d' /etc/passwd 删除第1行和第3行，中间是分号# sed -e '1d' -e '3d' /etc/passwd 删除第1行和第3行# sed --expression='1d' --expression='3d' /etc/passwd# sed '/^root/d' /etc/passwd 使用正则表达式，要加双斜杠# sed '/root/,/sync/d' /etc/passwd 删除包含root到sync的行# sed '/root/!d' /etc/passwd !表示后面的命令对所有没有被选定的行发生作用 # head -n 5 /etc/passwd |cat -n |sed '2d' 指定删除第二行# head -n 5 /etc/passwd |cat -n |sed '2,3d' 删除第二行到第三行，中间为逗号，表示范围# head -n 5 /etc/passwd |cat -n |sed '1d;5d' 删除第一行和第五行，中间为分号，表示单独操作# head -n 5 /etc/passwd |cat -n |sed '1d;5d;3d'# head -n 5 /etc/passwd |cat -n |sed '1,3d;5d'# head -5 /etc/passwd |sed '/daemon/d'删除vsftpd.conf里所有的注释和空行# sed '/^#/d;/^$/d' /etc/vsftpd/vsftpd.conf 替换sed替换语法：sed ‘范围 s/老字符/新字符/标记’ filesed ‘范围 s#老字符#新字符#标记’ file如果不指定范围，默认范围是整个文件。sed ‘y/老字符/新字符/‘ 12345678# head -5 /etc/passwd | nl |sed '1,4s/nologin/NOLOGIN/g'# sed 's#nologin#NOLOGIN#g' /etc/passwd g是标记，表示全部，也可以使用数字，1,2,3等进行替换，#号只有替换的时候才能用# sed 's/nologin/NOLOGIN/g' /etc/passwd# sed '1s/root/--&amp;--/2' /etc/passwd 老字符支持正则表达式，新字符不支持正则表达式，除了"\n\&amp;"，这里的"&amp;"表示前面的关键字# sed '1&#123;s/root/ROOT/;s/bin/BIN/&#125;' /etc/passwd 多次替换使用花括号和分号# sed 'y/abc/xyz/' file y也是替换，a-&gt;x b-&gt;y c-&gt;z# cat /etc/sysconfig/network-scripts/ifcfg-eth0 | sed '/^onboot/c\onboot=yes' 将onboot开头的行替换成onboot=yes，行替换# cat /etc/sysconfig/network-scripts/ifcfg-eth0 | sed 's/ONBOOT="no"/ONBOOT="yes"/' 修改之后保存 1# sed -i '/^root/a\the first line' file --修改源文件的操作要谨慎]]></content>
      <categories>
        <category>linux-basic</category>
      </categories>
      <tags>
        <tag>linux-basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程管理]]></title>
    <url>%2F2018%2F06%2F10%2Flinux-process%2F</url>
    <content type="text"><![CDATA[本文主要介绍Linux进程相关的命令，ps、kill、top等。 1. ps命令ps常规用法 12345678910111213141516# ps aux 查看所有进程# ps -ef 查看所有进程# ps -f -u apache 查看某个用户的进程# ps -f -C httpd 通过进程名显示进程# ps -f -p 3150,7298,6544 通过进程id显示进程# ps aux --sort=-pcpu,+pmem 以cpu使用量排序，如果cpu使用量相同，则以内存使用量排序# ps -f --forest -C httpd 显示ASCII进程树# ps -o pid,uname,comm -C httpd 显示父进程的子进程# ps -o pid,uname,comm --ppid 3438 # ps -e -o pid,comm,etime 显示进程已运行的时间# watch -n 1 'ps -e -o pid,uname,cmd,pmem,pcpu --sort=-pmem,-pcpu | head -15'还有一个pstree命令# pstree# pstree -a# pstree -p apache 2. top相关命令 top命令 123# top# top -b -n 1# top -b -n 1 -p 1 htop命令 123456# yum install htop -y 没有htop命令就安装# htop# htop -d 2 2秒刷新一次# htop -C 没有颜色# htop -u apache u=user# htop -p xxx，xxx p=pid dstat 命令 12345# dstat 直接运行# dstat -n n是net# dstat -d d是disk# dstat -m m是memory# dstat -l l是load average 显示系统负载情况 glances命令 123456789# yum install epel-release -y# yum install glances -y 没有glances命令就安装# glances# glances -t 2 刷新频率2秒，默认是1秒# yum install python-jinja2 -y# glances -o csv -f glances.csv 输出为csv格式# glances -o HTML -f /var/www/html/ 输出为html格式# glances -s -B 192.168.1.153 -p 4000 -P123 在服务器端启动# glances -c 192.168.1.153 -p 4000 -P123 再客户端连接 3. kill命令发送指定的信号到相应进程。 12# kill -l 查看有那些信号# kill -9 xxx 给xxx进程发生9号信号 查找进程PID的命令 12345# ps -ef | grep httpd# pstree -p apache# pidof httpd# pgrep httpd# lsof /usr/sbin/httpd 杀死进程的命令 1234# kill -9 pid# killall httpd# pkill httpd# skill httpd lsof命令12345678910lsof 打开文件列表lsof /usr/sbin/httpd 查找某个文件相关的进程lsof -c mysql 查找某个程序进程所打开的文件信息lsof -c mysql -c apache 多个lsof -p 1 通过某个进程号显示该进行打开的文件lsof -p 1,2,3 多个lsof -i 列出所有的网络连接lsof -i tcp 列出所有的tcp连接lsof -i udp 列出所有的udp连接lsof -i :3306 列出谁在使用某个端口 4 . 前台进程和后台进程(1)command &amp;让进程在后台运行(2) jobs –l 查看后台运行的进程(3)fg %n 让后台运行的进程n到前台来(4)bg %n 让进程n到后台去 123456# glances -s -B 127.0.0.1 &amp;# glances -s -B 127.0.0.1 暂停程序运行CTRL+Z# jobs -l 查看暂停的程序# bg %1 切换程序至后台# fg %1 切换程序至前台# kill %1 终止后台程序]]></content>
      <categories>
        <category>linux-basic</category>
      </categories>
      <tags>
        <tag>linux-basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文本文件处理(3)]]></title>
    <url>%2F2018%2F06%2F09%2Flinux-awk%2F</url>
    <content type="text"><![CDATA[本文主要介绍awk命令的用法。 1. awk简介awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk。awk名字来源于三位创造者Aho、Weinberger和Kernighan统称。awk擅长处理文本数据。 2. 基本用法awk [-Ffs] [-v var=value] [program | -f progfile …] [file …]选项与参数：-F 指定域分隔符，例如：-F “|”，即以|作为域分隔符，默认分隔符为一个或多个空格或TAB，即”[[:space:]][[:space:]]*”。-v 定义变量，从shell给awk传递变量，如-vDATE=$DATE，即将shell中$DATE变量值传递给awk变量DATE。-f 指定脚本文件，例如-f progfile。program 操作模块 示例： 123456# awk -F ":" '&#123;print $1,$2&#125;' /etc/passwd -F 分隔符 $1是第一列 $2是第二列# awk '&#123;print $0&#125;' /etc/passwd 打印所有列# awk -F: '&#123;print $1&#125;' /etc/passwd 打印第一列# awk -F: '&#123;print $1"\thaha\t"$3&#125;' /etc/passwd 打印第一，三列# awk -F":" '&#123;print $1" 的uid是 "$3&#125;' /etc/passwd# echo "haha,hehe.heihei" |awk -F"[,.]" '&#123;print $1&#125;' 分隔符可以有多个 模式匹配格式：awk ‘/patten/ {action} ‘ filename //纯字符匹配 !//纯字符不匹配 ~//字段值匹配 !~//字段值不匹配 ~/a1|a2/字段值匹配a1或a2 123456789101112131415# awk '/mysql/' /etc/passwd# awk '/mysql/&#123;print &#125;' /etc/passwd# awk '/mysql/&#123;print $0&#125;' /etc/passwd --三条指令结果一样# awk '!/mysql/&#123;print $0&#125;' /etc/passwd --输出不匹配mysql的行# awk '/mysql|mail/&#123;print&#125;' /etc/passwd# awk '/mysql|postfix|root/' /etc/passwd# awk '!/mysql|mail/&#123;print&#125;' /etc/passwd# awk '/mail/,/mysql/&#123;print&#125;' /etc/passwd --区间匹配# awk '/^root/,/^mail/' /etc/passwd --区间匹配# awk '/[2][7][7]*/&#123;print $0&#125;' /etc/passwd --匹配包含27为数字开头的行，如27，277，2777...# awk -F: '$1~/mail/&#123;print $1&#125;' /etc/passwd --$1匹配指定内容才显示# awk -F: '$3~/^0$/&#123;print $1&#125;' /etc/passwd# awk -F: '&#123;if($1~/mail/) print $1&#125;' /etc/passwd --与上面相同# awk -F: '$1!~/mail/&#123;print $1&#125;' /etc/passwd --不匹配# awk -F: '$1!~/mail|mysql/&#123;print $1&#125;' /etc/passwd 操作模块 awk [-Ffs] ‘BEGIN {处理文件前执行的代码块} ｛处理文件过程中执行的代码块} END {处理文件后执行的代码块}’ filename BEGIN｛｝｛ ｝END｛｝ BEGIN和END只执行一次。 12345678910111213# awk -F: '&#123;print "用户名\t\tUID"&#125;&#123;print $1"\t"$3&#125;' /etc/passwd# awk -F: 'BEGIN&#123;print "用户名\t\tUID"&#125;&#123;print $1"\t"$3&#125;' /etc/passwd# head -1 /etc/passwd |awk -F: '&#123;print $7":"$6":"$5":"$4":"$3":"$2":"$1&#125;'# head -1 /etc/passwd |awk -F: 'BEGIN &#123;OFS=":"&#125;&#123;print $7,$6,$5,$4,$3,$2,$1&#125;'# head -1 /etc/passwd | awk 'BEGIN&#123;FS=":"&#125;&#123;OFS="@"; print $7,$6,$5,$4,$3,$2,$1&#125;'# head -1 /etc/passwd | awk 'BEGIN&#123;FS=":";OFS="#"&#125;&#123;print $7,$6,$5,$4,$3,$2,$1&#125;'awk可以用做小数（浮点数）的运算# echo $[1.23*2] --错误做法# echo |awk '&#123;print 1.23*2&#125;' --正确做法# echo 1.23*2 | bc --正确做法# awk 'BEGIN&#123;print 1.23*2&#125;' 内置变量 属性 说明 $0 当前记录行，代表一行记录 $1到n 当前记录的第n个字段，字段间由FS分隔 FS 输入字段分隔符，默认是空格或tab NF 当前记录中的字段个数，就是有多少列，一般取最后一列字段 NR 已经读出的记录数，就是行号，从1开始 RS 输入的记录分隔符，默认为换行符 OFS 输出字段分隔符，默是空格 ORS 输出的记录分隔符，默认为换行符 示例 1234567891011121314151617打印第五行# head -5 /etc/passwd |tail -1# awk 'NR==5 &#123;print $0&#125;' /etc/passwd# awk '&#123;if (NR==5) print $0&#125;' /etc/passwd打印第五行和第六行# awk 'NR==5 || NR==6 &#123;print $0&#125;' /etc/passwd# awk 'NR&gt;=5 &amp;&amp; NR&lt;=6 &#123;print $0&#125;' /etc/passwd打印五到十行，并在前面加上行号# awk 'NR&lt;=10 &amp;&amp; NR&gt;=5 &#123;print FNR,$0&#125;' /etc/passwd打印奇数行 (删除偶数行)# awk 'NR%2==1 &#123;print FNR,$0&#125;' /etc/passwd打印偶数行 (删除奇数行)# awk 'NR%2==0 &#123;print FNR,$0&#125;' /etc/passwd]]></content>
      <categories>
        <category>linux-basic</category>
      </categories>
      <tags>
        <tag>linux-basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文本文件处理(2)]]></title>
    <url>%2F2018%2F06%2F09%2Flinux-grep%2F</url>
    <content type="text"><![CDATA[本文主要介绍grep命令的用法。 1. grep的简介文本搜索工具，根据用户指定的文本模式对目标文件进行逐行搜索，显示能够被模式所匹配到的行。配合正则表达式的使用可以实现强大的文本处理。 2. 基础用法1234567# grep [-cinv] [--color=auto] '搜寻字符串' filename选项与参数：-c ：计算找到 '搜寻字符串' 的次数-i ：忽略大小写的不同，所以大小写视为相同-n ：顺便输出行号-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！--color=auto ：可以将找到的关键词部分加上颜色的显示喔！ 示例： 123456789101112131415# grep root /etc/passwd# grep -n root /etc/passwd -n:输出行号# grep -c "bash" /etc/passwd -c:个数# grep -v root /etc/passwd -v:反向匹配# echo "hello world" | grep -i "HELLO" -i:忽略大小写# dmesg | grep -n --color=auto 'eth' --color颜色高亮# dmesg | grep -n -A3 -B2 --color=auto 'eth' -A -B -C 将匹配到的那一行的前面后面的行显示出来# cat patfile bash nologin# grep -f patfile /etc/passwd --color -f:文件# grep "root" / -r --color=auto -r:递归# grep "main()" . -r --include *.&#123;php,html&#125; --include:包含# grep "main()" . -r --exclude "README" --exclude:不包含# grep "main()" . -r --exclude-from filelist 3. 正则表达式1234567891011121314151617181920212223242526. 单个字符^ 开始$ 结尾* 匹配零个或多个先前字符[] 匹配一个指定范围内的字符[^] 匹配一个不在指定范围内的字符x\&#123;m\&#125; 重复字符x，m次，如：'0\&#123;5\&#125;'匹配包含5个o的行x\&#123;m,\&#125; 重复字符x,至少m次，如：'o\&#123;5,\&#125;'匹配至少有5个o的行w 匹配文字和数字字符，也就是[A-Za-z0-9]W w的反置形式，匹配一个或多个非单词字符，如点号句号等+ 匹配一个或多个先前的字符? 匹配零个或多个先前的字符a|b|c 匹配a或b或cx&#123;m&#125;,x&#123;m,&#125;,x&#123;m,n&#125; 作用同x\&#123;m\&#125;,x\&#123;m,\&#125;,x\&#123;m,n\&#125;[:alnum:] 文字数字字符[:alpha:] 文字字符[:digit:] 数字字符[:graph:] 非空字符（非空格、控制字符）[:lower:] 小写字符[:cntrl:] 控制字符[:print:] 非空字符（包括空格）[:punct:] 标点符号[:space:] 所有空白字符（新行，空格，制表符）[:upper:] 大写字符[:xdigit:] 十六进制数字（0-9，a-f，A-F） 示例： 1234567891011# grep -E 'r..t' /etc/passwd --color# grep -E 'r.*t' /etc/passwd --color# grep -E 'r.+t' /etc/passwd --color# cat /etc/httpd/conf/httpd.conf | grep -v '^#' | grep -v '^$'# cat /etc/httpd/conf/httpd.conf | grep -v -e '^#' -e '^$'# cat /etc/httpd/conf/httpd.conf | grep -v -E '#|^$'# grep -E '[io]n' /etc/passwd --color# grep -E '[^io]n' /etc/passwd --color# grep 'ro\&#123;2\&#125;' /etc/passwd --color 不要加-E# grep 'ro\&#123;1,\&#125;' /etc/passwd --color 贪婪模式，尽可能多的匹配# grep 'ro\&#123;1,3\&#125;' /etc/passwd --color 至少1次，最多3次]]></content>
      <categories>
        <category>linux-basic</category>
      </categories>
      <tags>
        <tag>linux-basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文本文件处理(1)]]></title>
    <url>%2F2018%2F06%2F08%2Flinux-text%2F</url>
    <content type="text"><![CDATA[本文主要介绍Linux下文本文件的查看等操作相关的命令。 1. 文本文件查看命令cat命令 查看文件内容123cat 1.txt 查看文本文件内容cat -n 1.txt 显示行号，空行也算一行cat -nb 1.txt 显示行号，空行忽略 head命令 显示文件前十行的内容(默认)123head 1.txthead -n 20 1.txt 显示文件前20行的内容head -20 1.txt 显示文件前20行的内容 tail命令 查看文件最后十行的内容(默认)1234tail -n 5 1.txt 最后5行tail -5 1.txt 最后5行tail -f 1.txt 动态查看文件内容tailf 1.txt 动态查看文件内容 more命令 分页显示1more 1.txt less命令 分页显示1less 1.txt tac命令 文件内容的输出上下反，不影响源文件1tac 1.txt tac 反过来 cat rev命令 左右反，不影响源文件1rev 1.txt tee命令 将数据重定向到文件和标准输出12ls | tee out.txtls | tee out.txt | cat -n 2. 其他命令wc命令 字符统计123cat /etc/passwd | wc -lcat /etc/passwd | wc -ccat /etc/passwd | wc -w cut命令123who|cut -b 3-5cut -f2 -d";" test2.txt -d分隔符是":"，-f是列 cut -f2 --complement test.txt --complement 选项提取指定字段之外的列 tr命令1234567echo "HELLO WORLD" | tr 'A-Z' 'a-z' 将输入字符由大写转换为小写hello worldecho "hello 123 world 456" | tr -d '0-9' 使用tr删除字符hello world cat text | tr '\t' ' ' 将制表符转换为空格 sort命令 排序1sort -t ' ' -k 1.2 facebook.txt uniq命令 忽略文件中的重复行12sort file.txt | uniq sort -u file.txt]]></content>
      <categories>
        <category>linux-basic</category>
      </categories>
      <tags>
        <tag>linux-basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum命令详解]]></title>
    <url>%2F2018%2F06%2F08%2Flinux-yum%2F</url>
    <content type="text"><![CDATA[本文主要介绍centos系统程序包管理软件Yum命令的详细使用方法。Yum软件包管理方式，在Red Hat,Fedora,CentOS等发行版本上运用广泛。 1. Yum的工作机制将诸多程序的包信息和头文件提取出来，放到一个集中的地方，记录其依赖关系。在下次安装的时候，均于存储的库文件查找相应的对应关系，再安装所依赖的软件程序。 2. Yum配置文件主配置文件：/etc/yum.conf12345678[main]：主名称，固定名称cachedir=/var/cache/yum/$basearch/$releasever 缓存目录keepcache=0 是否保存缓存debuglevel=2 调试级别exactarch=1 是否做精确严格的平台匹配gpgcheck=1 检查来源法性和完整性plugins=1 是否支持插件installonly_limit=4 同时安装几个 子配置文件：/etc/yum.repos.d/*.repo12345678910111213141516[repository ID] ：ID名称，即仓库名称，不可与其他ID重命name= (对ID名称的说明)baserul=URL1URL2URL3 （如果同一个源有多个镜像，可以在此我写几个，但每个URL需换行）mirrorlist= (有一台服务器在网络上，保存了多个baseurl，如果使用这项，就不使用baseurl项）enabled=&#123;1|0&#125;gpgcheck=&#123;1|0&#125;repo_gpgcheck= (检查仓库的元数据的签名信息)gpgkey=URL (gpg密钥文件）enablegroups= &#123;1|0&#125;&#125; (是否在此仓库中上使用组来指管理程序包)failovermethod= roundrobin|priority (对多个baseurl做优先级的，roundrobin为轮循，priority为优先级，默认为轮循，意为随机）keepalive= (如果对方是http 1.0是否要保持连接)username= (yum的验证用户)password= (yum的验证用户密码)cost= (默认baseurl都为1000) Yum仓库的配置文件示例12345678[epel]name=Extra Packages for Enterprise Linux 6 - $basearch#baseurl=http://download.fedoraproject.org/pub/epel/6/$basearchmirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-6&amp;arch=$basearchfailovermethod=priorityenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6 其中使用了变量$releasever:当前os的发行版本的主版本号$arch:平台$basearch:基础平台 3. 常用的国内Yum源 中科大http://mirrors.ustc.edu.cn/centos/CentOS-Base.5.mirrors.repohttp://mirrors.ustc.edu.cn/centos/6/os/x86_64/ 搜狐http://mirrors.sohu.com/help/CentOS-Base-sohu.repohttp://mirrors.sohu.com/centos/6/os/x86_64/ REMIhttp://rpms.remirepo.net/ REMI网站https://mirrors.tuna.tsinghua.edu.cn/remi/ REMI中国镜像http://rpms.remirepo.net/enterprise/http://rpms.remirepo.net/enterprise/remi-release-6.rpm 163源http://mirrors.163.com/centos/ 阿里云https://opsx.alibaba.com/mirror 中国科技大学http://centos.ustc.edu.cn/centos/ rpm包常用下载地址https://centos.pkgs.org/http://rpmfind.net/http://dl.fedoraproject.org/pub/epel/ 4. 制作Yum源上面介绍的都是网络上做好的yum源，我们也可以自己来制作yum源。 本地光盘源 123456789mkdir /media/cdrommount /dev/cdrom /media/cdrom/cd /etc/yum.repos.d/vim cdrom.repo[cdrom]name=cdrom repolistbaseurl=file:///media/cdrom/gpgcheck=0enabled=1 文件夹源 1234567891011mkdir /yumyum -y install createrepomv *.rpm /yumcreaterepo /yumcd /etc/yum.repos.d/vim cdrom.repo[local]name=local directory repolistbaseurl=file:///media/cdrom/gpgcheck=0enabled=1 网络yum源 123yum install httpd -yln -s /yum /var/www/html/service httpd start 添加新的yum源： 12yum install yum-utils -yyum-config-manager --add-repo=file:///yum/ 5. yum命令使用安装软件1yum install packagename 升级软件1yum update packagename 卸载软件1yum remove packagename 搜索已安装软件包1yum search keyword 查看软件包额外信息1yum info packagename 查看可安装的软件包1yum list | less 列出已安装软件包1yum list installed | less 显示仓库的所有程序包1yum list 查看特定文件属于哪个软件包1yum provides /etc/sysconfig/nfs 列出可获得的软件组1yum grouplist 安装某个特定软件组1yum groupinstall 升级软件组1yum groupupdate 'Graphical Internet' 卸载软件组1yum groupremove 'DNS Name Server' 列出当前yum软件源1yum repolist 查看yum安装的历史123yum historyyum history info 3yum history undo 4 安装及升级本地程序包12yum localinstall rpmfile1yum localupdate rpmfile1 6. 使用Yumdownloader下载RPM软件包及其所有依赖包如果系统中没有yumdownloader命令，可以执行如下命令安装：1yum -y install yum-utils 具体使用方法：1234# yumdownloader httpd# yumdownloader --resolve httpd# yumdownloader --resolve --destdir=/root/mypackages/ httpd# yumdownloader "@Development Tools" --resolve --destdir /root/mypackages/]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos下Yum安装PHP5.5、PHP5.6、PHP7.0]]></title>
    <url>%2F2018%2F06%2F08%2Flinux-php-version%2F</url>
    <content type="text"><![CDATA[本文主要介绍centos系统上如何升级php的版本。Centos系统默认有php，但是默认的版本太低，手动安装有一些麻烦，于是使用Yum来安装。 1. 检查当前安装的PHP包1yum list installed | grep php 如果已经安装PHP的包，先卸载掉。1yum remove php.x86_64 php-cli.x86_64 php-common.x86_64 php-gd.x86_64 php-ldap.x86_64 php-mbstring.x86_64 php-mcrypt.x86_64 php-mysql.x86_64 php-pdo.x86_64 2. 安装新的Yum源Centos 5.x1rpm -Uvh http://mirror.webtatic.com/yum/el5/latest.rpm CentOs 6.x1rpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpm CentOs 7.x12rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 3. 安装PHP1yum install php55w.x86_64 php55w-cli.x86_64 php55w-common.x86_64 php55w-gd.x86_64 php55w-ldap.x86_64 php55w-mbstring.x86_64 php55w-mcrypt.x86_64 php55w-mysql.x86_64 php55w-pdo.x86_64 1yum install php56w.x86_64 php56w-cli.x86_64 php56w-common.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64 1yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64 4. 安装PHP FPM123yum install php55w-fpmyum install php56w-fpmyum install php70w-fpm]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础02篇]]></title>
    <url>%2F2018%2F06%2F08%2Flinux-basic-02%2F</url>
    <content type="text"><![CDATA[本文主要介绍文件系统、文件权限、文件打包和解包及软件包管理方面的命令。 1. 文件系统 磁盘分区磁盘分区主要使用fdisk（sfdisk）命令和parted命令。 1234# sfdisk-l# sfdisk-s# cfdisk-Ps# fdisk -l 格式化mkfs命令 12# mkfs.ext4# mfks -t ext4 /dev/sda6 挂载mount命令 123# mount /dev/sda5 /test# mount /soft/rhel-server-6.3-x86_64-dvd.iso /yum/ -o loop# mount -o remount,noexec / 查看磁盘 1234567# df –h 显示已经挂载的分区列表# df –T 显示分区列表的文件系统类型# du -sh dir1 估算目录 'dir1' 已经使用的磁盘空间# fsck 文件系统修复# dumpe2fs /dev/sda1 显示磁盘状态# findmnt 查找已经被挂载的文件系统# blkid 2. 文件权限 基本的权限-rw——- 1 root root 1112 Mar 27 03:14 anaconda-ks.cfgrw- — — 权限用九位来表示前三位代表用户u(user），中间三位代表组g(group），后三位代表o（others）基本权限有三种 r(read)读 w(write)写 x(execute)执行 a表示allr 读权限 针对目录，有r权限，就代表能对此目录有列表的功能 (就是ls列出来的功能） 针对文件，有r权限，就代表能对此文件有阅读的功能 (就是指cat一类的命令）w 写权限 针对目录，有w权限，就代表在此目录下创建文件或者子目录 (touch,mkdir等） 针对文件，有w权限，就代表能在此文件写入内容或者修改 (&gt; ,&gt;&gt;, vi 再写等）x 执行权限 针对目录，有x权限，就代表能进入此目录 （cd) 针对文件，有x权限，就代表能执行它 （命令，可执行文件等）1234567# chmod a+x 1.txt# chmod g+x 1.txt# chmod a+x 1.txt# chmod a-r 1.txt# chmod o-rwx 1.txt # chmod u-w,g+x,o+x abc --也可以一次性连写# chmod o=rwx 1.txt rw- — —110 000 000 –二进制 600 –十进制 权限用数字来表示 (r,w,x都可以用数字来表示）r 4w 2x 1 -rw-r–r– 这个以数字表示为644 修改文件所有者和组123456789101112# touch 1.txt# ll 1.txt -rw-r--r-- 1 root root 0 Aug 20 15:28 1.txt# chown user2.user2 1.txt # ll 1.txt -rw-r--r-- 1 user2 user2 0 Aug 20 15:28 1.txt# chown user3:user3 1.txt # ll 1.txt -rw-r--r-- 1 user3 user3 0 Aug 20 15:28 1.txt# chown user2:user3 1.txt # ll 1.txt -rw-r--r-- 1 user2 user3 0 Aug 20 15:28 1.txt 特殊权限s权限：一个可执行文件拥有s位时，当别的用户来执行这个可执行文件的话，使用的权限是此可执行文件属主或者属组的权限只针对前三位，中间三位。对目录可以加，但是无效，因为目录不是命令，根本不能执行它12345678910# ll /usr/bin/passwd-rwsr-xr-x. 1 root root 30768 Feb 17 2012 /usr/bin/passwd# ll /etc/shadow----------. 1 root root 1434 Jul 17 09:27 /etc/shadow``` t权限，只针对目录有效有t位的目录，任何用户在有权限的情况下是可以创建文件和目录，但是自己只能删除自己创建的目录。```markdown# ll -d /tmp/ s位和t位注意的地方：用数字表示前三位上加s 4中间三位加s 2后三位加t 1 s位和t位大小写的区别小写的话就表示 有x执行权限大写的话就表示 没有x执行权限 隐藏属性12345678# chattr +a file1 只允许以追加方式读写文件# chattr +c file1 允许这个文件能被内核自动压缩/解压# chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件# chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接# chattr +s file1 允许一个文件被安全地删除# chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘# chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件# lsattr 显示特殊的属性 3.文件打包和解包示例：123456789101112# tar -cvf archive.tar file1 创建一个非压缩的 tarball# tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件# tar -tf archive.tar 显示一个包中的内容# tar -xvf archive.tar 释放一个包# tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下# tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包# tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包# tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包# tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包# zip file1.zip file1 创建一个zip格式的压缩包# zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包# unzip file1.zip 解压一个zip格式压缩包 4. 软件包管理 rpm包管理 1234567891011121314# rpm -ivh package.rpm 安装一个rpm包# rpm -ivh --nodeps package.rpm 安装一个rpm包而忽略依赖关系警告# rpm -U package.rpm 更新一个rpm包但不改变其配置文件# rpm -e package_name.rpm 删除一个rpm包# rpm -qa 显示系统中所有已经安装的rpm包# rpm -qa | grep httpd 显示所有名称中包含 "httpd" 字样的rpm包# rpm -qi package_name 获取一个已安装包的特殊信息# rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表# rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表# rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供# rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表# rpm --import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书# rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包# yum管理工具 123456789# yum install package_name 下载并安装一个rpm包# yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系# yum update package_name.rpm 更新当前系统中所有安装的rpm包# yum update package_name 更新一个rpm包# yum remove package_name 删除一个rpm包# yum list 列出当前系统中安装的所有包# yum search package_name 在rpm仓库中搜寻软件包# yum clean packages 清理rpm缓存删除下载的包# yum clean all 删除所有缓存的包]]></content>
      <categories>
        <category>linux-basic</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础01篇]]></title>
    <url>%2F2018%2F06%2F07%2Flinux-basic-01%2F</url>
    <content type="text"><![CDATA[本文主要介绍文件和目录、文件搜素相关的命令。 1. 文件和目录 cd命令 123456789cd /进入系统根目录# cd /cd /home进入根下的home目录# cd /homecd ..进入当前目录的上一级目录# cd ..cd -进入上次所在的目录# cd - ls和pwd命令 12345ls注意ls的参数# ls -a -l -d -hpwd显示当前工作路径# pwd mkdir命令 1234mkdir /test在根目录下创建test目录# mkdir /testmkdir -p /a/b/c/d创建多级目录，-p参数是不报错的# mkdir -p /a/b/c/d cp命令 1234cp file1 file2复制一个文件# cp a.txt b.txtcp -ar dir1 dir2 复制一个目录# cp -ar /abc /test mv命令 1234mv /opt/a /root/移动文件# mv /opt/a /root/mv /opt/a /root/移动文件# mv /opt/a /root/b touch命令 1234567touch 1.txt创建文件# touch 1.txt# touch &#123;a..z&#125;# touch &#123;a..z..2&#125;# touch a&#123;1..5&#125;# touch a&#123;1..5&#125;.txt# touch &#123;1..5&#125;&#123;a..f&#125; file命令 12查看文件的类型# file /dev/sda tree命令 123显示文件和目录由根目录开始的树形结构# yum install tree# tree –L 1 2. 文件搜素 whereis和which命令 123查找二进制文件# which cat# whereis whereis find命令 按名称查找1234# find /etc/ -name grub.conf# find /etc/ -name "*.conf"# find /etc/ -name ".*"# find /test/ -iname Abc 按类型查找1234567# find / -type f# find / -type b# find / -type s# find / -type c# find / -type p# find / -type d# find / -type l 按大小查找123456# find / -size +500M# find / -size +1G# find / -size +50k# find / -size -1M# find / -size +3c# find / -size +80M -size -100M 按时间查找123456789101112131415# stat 1 |tail -3Access: 2014-07-23 11:56:42.297572398 +0800 --atime 阅读过，用cat,tail,head,more,less命令等或者vi访问过，但没有修改；执行过也会改变Modify: 2014-07-23 11:56:44.836572907 +0800--mtime 修改过内容，用vi修改过或者echo一个值重定向Change: 2014-07-23 11:56:44.856885177 +0800 —ctime 改变过内容，属主，属组，权限，创建软链接，硬链接等找出 3 天”以前”被改动过的文件(&gt; 72 小时)find /var/log/ -mtime +3 -type f找出 3 天内被改动过的文件(0 ~ 72 小时内)find /var/log/ -mtime -3 -type f找出前第 3 天被改动过的文件(72 ~ 96 小时)find /var/log/ -mtime 3 -type ffind /var/log/ -mtime +2 -mtime -4 -type f在20-50天内修改过的文件find ./ -mtime +20 -a -mtime -50 -type f在2018-04-11当天修改的文件find / -type f -newermt '2018-04-11 00:00' -a -not -newermt '2018-04-11 23:56' locate命令 速度快，通过系统带的一个数据库去查找，数据是非实时的。速度快，通过系统带的一个数据库去查找，数据是非实时的。系统每天自动更新一次，是通过时间任务执行的：/etc/cron.daily/mlocate.cron/usr/bin/updatedb主要用来更新数据库，通过crontab自动完成的/usr/bin/locate 查询文件位置/etc/updatedb.confupdatedb的配置文件/var/lib/mlocate/mlocate.db 存放文件信息的文件1# locate passwd]]></content>
      <categories>
        <category>linux-basic</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
